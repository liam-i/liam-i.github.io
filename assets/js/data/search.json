[ { "title": "App：应用程序的结构和行为", "url": "/posts/app/", "categories": "iOS, SwiftUI", "tags": "SwiftUI", "date": "2024-05-05 20:05:36 +0800", "snippet": "SwiftUI 的 App 协议定义了一个 SwiftUI 应用的顶级结构和行为。通过遵循 App 协议，你可以定义一个结构体来表示你的整个应用，并使用这个结构体来配置应用的场景和生命周期行为。定义你的 App要创建一个遵循 App 协议的结构体，你需要定义一个 body 属性，该属性返回一个或多个 Scene 实例。这些 Scene 描述了应用的用户界面和可能的状态。例如：import S...", "content": "SwiftUI 的 App 协议定义了一个 SwiftUI 应用的顶级结构和行为。通过遵循 App 协议，你可以定义一个结构体来表示你的整个应用，并使用这个结构体来配置应用的场景和生命周期行为。定义你的 App要创建一个遵循 App 协议的结构体，你需要定义一个 body 属性，该属性返回一个或多个 Scene 实例。这些 Scene 描述了应用的用户界面和可能的状态。例如：import SwiftUI@mainstruct MyApp: App { var body: some Scene { WindowGroup { ContentView() } }}在这个例子中，MyApp 结构体通过 @main 属性标记为程序的入口，并遵循 App 协议，实现了必需的 body 属性。body 属性返回了一个 WindowGroup 场景，该场景包含了一个 ContentView 实例。当你的应用启动时，它会自动创建一个包含 ContentView 的新窗口。配置多个场景如果你的应用需要支持多个窗口或视图，你可以在 body 属性中定义多个 Scene。例如，你可以添加一个设置场景：import SwiftUI@mainstruct Mail: App { var body: some Scene { WindowGroup { MailViewer() }.commands { // 定义与这个场景相关的命令 } Settings { SettingsView() } }}生命周期App 结构体内部处理了应用场景的生命周期管理，比如启动时的初始化、从后台恢复到前台时的状态恢复、以及设备旋转导致的界面重排布等。这使得开发者无需直接干预这些底层细节，而能集中精力于构建用户界面和业务逻辑。状态共享App 支持在应用程序中声明状态，以在整个应用范围内共享数据和资源。例如，可以使用 StateObject 初始化数据模型，然后将该模型作为 ObservedObject 传递给其他视图，或者通过 .environment 或 .environmentObject 传递给应用程序中的 Scenes。例如：import SwiftUI@mainstruct Mail: App { @StateObject private var model = MailModel() var body: some Scene { WindowGroup { MailViewer() .environmentObject(model) // Passed through the environment. } Settings { SettingsView(model: model) // Passed as an observed object. } }} 注意: 在 iOS 14.0+ 和 macOS 11.0+ 推荐使用 App 协议来构建应用。然而，如果你的应用需要支持更早的操作系统版本，你可能需要使用传统的 UIApplicationDelegate 或 NSApplicationDelegate。 App 协议是 SwiftUI 框架的一部分，因此在使用之前需要确保你的项目已经导入了 SwiftUI 框架。 相关链接 SwiftUI App SwiftUI 中的 App 要领" }, { "title": "SwiftUI 与 UIKit 对标的视图", "url": "/posts/swiftui-uikit/", "categories": "iOS, SwiftUI", "tags": "SwiftUI", "date": "2024-05-03 20:05:36 +0800", "snippet": "Views &amp; ViewControllers &amp; Controls SwiftUI UIKit View UIView, UIViewController List UITableView, UITableViewController L...", "content": "Views &amp; ViewControllers &amp; Controls SwiftUI UIKit View UIView, UIViewController List UITableView, UITableViewController LazyVGrid, LazyHGrid UICollectionView, UICollectionViewController TabView UITabBarController, UIPageViewController Alert, ActionSheet UIAlertController NavigationView UINavigationBar, UIToolBar, UINavigationController, UISplitViewController Text, Label UILabel Button, Link UIButton Image UIImageView TextField UITextField TextEditor UITextView ScrollView UIScrollView ToolbarItem UINavigationItem HStack, LazyHStack UIStackView VStack, LazyVStack UIStackView ProgressView UIProgressView, UIActivityIndicatorView Picker UISegmentedControl, UIPickerView DatePicker UIDatePicker Toggle UISwitch Slider UISlider Stepper UIStepper Map MKMapView SwiftUI 中使用 UIKit SwiftUI UIKit UIViewRepresentable UIView UIViewControllerRepresentable UIViewController UIKit 中使用 SwiftUI SwiftUI UIKit View UIHostingController App Delegate SwiftUI UIKit App UIApplicationDelegate, UIWindowSceneDelegate " }, { "title": "SwiftUI：\"some View\" 到底是什么类型", "url": "/posts/some-view/", "categories": "iOS, SwiftUI", "tags": "SwiftUI", "date": "2024-05-02 22:28:18 +0800", "snippet": "两个同样描述的调整器，调整器的顺序不同，为什么 Text 表现出不同的结果？some View图中 text1 的类型是 SwiftUI 的 Text，text2 与 text3 返回的是一个 ModifiedContent 类型。some View 本质是 ModifiedContent&lt;Content, Modifier&gt; 结构，他包含了两个内容。在多嵌套的状态下，可以看作：...", "content": "两个同样描述的调整器，调整器的顺序不同，为什么 Text 表现出不同的结果？some View图中 text1 的类型是 SwiftUI 的 Text，text2 与 text3 返回的是一个 ModifiedContent 类型。some View 本质是 ModifiedContent&lt;Content, Modifier&gt; 结构，他包含了两个内容。在多嵌套的状态下，可以看作： some View &lt;–等价–&gt; ModifiedContent&lt;ModifiedContent, 最后一个修饰结构&gt;。而内部的 ModifiedContent 里面同样递归包含了 ModifiedContent&lt;ModifiedContent, 倒数第二个修饰结构&gt;。结论调整器的顺序不同会导致返回不同的 ModifiedContent 类型。回到最开始的问题：前者 Color 调整器针对的是包裹 Text 与 Padding 的 some View，而后者 Color 仅仅针对 Text，所以造成表现形式不同。" }, { "title": "Homebrew Tap：酿造你的个性化 macOS 软件库", "url": "/posts/brew-tap/", "categories": "工具, Homebrew", "tags": "Homebrew", "date": "2024-04-04 22:36:18 +0800", "snippet": "对于 macOS 用户来说，Homebrew 无疑是一个强大的软件包管理工具，它极大简化了软件的安装、更新和卸载。然而，有时候我们仍然会发现一些特定的、小众的或者专业的软件并不在其中。这时，Homebrew Tap 就成了救星，它允许我们添加和管理第三方仓库，也可以扩展和定制自己的软件库，从而满足更加个性化的需求。什么是 Homebrew Tap？Homebrew Tap 是 Homebre...", "content": "对于 macOS 用户来说，Homebrew 无疑是一个强大的软件包管理工具，它极大简化了软件的安装、更新和卸载。然而，有时候我们仍然会发现一些特定的、小众的或者专业的软件并不在其中。这时，Homebrew Tap 就成了救星，它允许我们添加和管理第三方仓库，也可以扩展和定制自己的软件库，从而满足更加个性化的需求。什么是 Homebrew Tap？Homebrew Tap 是 Homebrew 的扩展，让用户能添加第三方软件仓库。通过 Tap，能安装和管理 Homebrew 里没有的软件包。每个 Tap 就像独立仓库，提供更多额外的软件包供用户选择。如何使用 Homebrew Tap？使用 Homebrew Tap 很简单。先找到想添加的 Tap (通常是 GitHub 仓库)，然后按命令操作即可。添加 Tap tap [options] [user/repo] [URL]添加一个 tap 仓库。如果未指定参数，则列出所有已安装的 taps。详细教程brew tap &lt;user&gt;/&lt;repo&gt; # 不加 URL 默认克隆 github 存储库 此命令将 https://github.com/&lt;user&gt;/homebrew-&lt;repo&gt; 存储库克隆到 $(brew --repository)/Library/Taps。 之后，brew 将能够使用这个 tap 里的软件包(formulae)，你可以使用 brew [un]install 安装和卸载它们，并且当你运行 brew update 时 formulae 会自动更新。 注意：Tap 存储库命名必须用 “homebrew-” 前缀。例如：homebrew-something。但是，在命令 brew tap 中使用时可以省略 “homebrew-” 前缀。例如用 brew tap homebrew/cask 代替 brew tap homebrew/homebrew-cask。brew tap &lt;user&gt;/&lt;repo&gt; &lt;URL&gt; 此命令将在 URL 处克隆存储库。URL 不一定是 GitHub，也不一定是 HTTP。只要是 Git 可以处理的任何位置和任何协议都可以。 注意：如果 tap 仓库不在 GitHub 上，需要运行 brew tap --force-auto-update &lt;user/repo&gt; 才能启用自动更新。brew tap # 查看已安装的 Taps。注意：无参数 此命令会列出所有当前已添加的 Taps 仓库。移除 Tap untap [--force] tap […]移除已添加的 tap 存储库。详细教程brew untap &lt;user&gt;/&lt;repo&gt; [&lt;user&gt;/&lt;repo&gt; &lt;user&gt;/&lt;repo&gt; ...] 此命令将从 Homebrew 中移除指定的 Taps。untap 可以一次移除多个 Taps。 注意：移除 Tap 并不会卸载通过该 Tap 安装的软件包 (formulae)，但之后将无法从该 Tap 接收软件包更新。查看 Tap 信息 tap-info [--installed] [--json] [tap …]显示一个或多个 tap 的详细信息。如果未给定 tap 名称，则显示所有已安装 tap 的简要统计信息。详细教程brew tap-info liam-i/tap # 查看 liam-i/tap 的详细信息管理 Tap 中的软件包添加完 Tap 之后，你就可以像使用 Homebrew 的 homebrew/core 规范存储库中的软件包一样，使用 tap 里的软件包(formulae)。你可以使用 brew [un]install 安装和卸载它们，并且当你运行 brew update 时 formulae 会自动更新。 注意： 当我们每次只用 brew install &lt;formula&gt; 命令安装软件包时，brew 都会按以下顺序搜索来选择要使用的 formula： core formulae other taps 所以： 如果你需要从指定的 tap 安装 formula，则可以使用全路径名：&lt;user&gt;/&lt;repo&gt;/&lt;formula&gt;。 如果第三方 tap 包含的 formula 和 homebrew/core 规范存储库里的重名了，也需要使用全路径名 &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; 来安装 tap 里的软件包。 brew install vim # 从 homebrew/core 安装 vimbrew install username/repo/vim # 从自定义存储库安装 vim 其他管理 Tap 的用例：brew info &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 显示指定 Tap 中某个软件包的信息，包括版本、依赖等brew search &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 搜索该 Tap 中的软件包brew install &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 安装 Tap 中的软件包brew uninstall &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 卸载 Tap 中的软件包brew upgrade &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 升级 Tap 中的软件包（或使用 brew upgrade 更新所有可升级的软件包）brew upgrade # 更新所有可升级的软件包brew update # 更新所有可升级的软件包综上所述，如果你想让自定义 tap 的 formulae 更易于安装使用，建议你为自定义 formulae 指定名称时，尽量避免与 homebrew/core 里的重复。 Taps (Third-Party Repositories)酿造你的个性化软件库通过 Homebrew Tap，你可以轻松地酿造属于自己的个性化软件库。以下是具体步骤和归纳：创建 Tap tap-new [options] user/repo生成一个新的 tap 仓库模板，存放到 $(brew --repository)/Library/Taps 目录。详细教程brew tap # 查看 tap 仓库列表brew tap-new liam-i/tap # 生成一个 liam-i/tap 仓库模板文件（如果不想要 git 仓库，可以加上 --no-git 参数） 如果 brew tap 查看本地没有需要的 Tap 仓库，且远程代码平台也没有，则可以使用 brew tap-new 生成一个。 如果本地没有，但是远程代码平台有，则可以 添加-tap。创建 Formula要在 Homebrew Tap 中添加一个软件包，首先需要为该软件包创建一个 Formula。Formula 本质上是一个 Ruby 脚本，用于描述如何安装软件包。以下是具体步骤： create [options] URL生成一个 formula，或者使用 --cask 为 URL 处的可下载文件生成一个 cask，然后在编辑器中将其打开。Homebrew 将尝试自动生成 formula 的名称和版本。详细教程，完整的 API。brew create --tap liam-i/tap https://github.com/liam-i/ybox/archive/refs/tags/20240404.tar.gz --tap: 在给定的 &lt;user&gt;/&lt;repo&gt; 仓库下生成 formula 文件。这个示例中在 liam-i/tap 下生成了一个名为 ybox.rb 的 formula 文件。后面的 URL 是指向我们需要发布的软件包，这个软件包必须必须提前准备好。 命令执行成功会有信息提示我们。比如存放路径 /opt/homebrew/Library/Taps/liam-i/homebrew-tap/ybox.rb。如果你是 macOS Intel 电脑，存放路径的前缀将会是 /usr/local。 命令执行成功后，将自动在编辑器 (例如 vscode) 里打开 ybox.rb，以方便你可以编辑它。编写 Formula edit [options] [formula|cask|tap …]在 EDITOR 或 HOMEBREW_EDITOR 设置的编辑器 (例如 vscode) 中打开 formula, cask 或 tap，或者如果没有给定参数则打开 Homebrew 存储库进行编辑。详细教程brew edit ybox # 打开 ybox.rb 进行编辑对于每个要添加的软件包，你需要编写一个相应的 Formula。Formula 是一个 Ruby 脚本，用于描述如何安装、配置和卸载软件包。参考 完整的 API 文档。部分语法要点： desc: 用于提供软件包的简短描述。 homepage: 指定软件包的官方网站。 url: 提供软件包的下载链接。 sha256: 是下载文件的校验和，确保文件未被篡改。 depends_on: 声明软件包的依赖关系。 install: 方法定义了安装过程。 test: 方法是可选的，用于验证安装后的软件包功能。编写 Formula：Formula 文件需要遵循特定的 Ruby 语法和结构：# Documentation: https://docs.brew.sh/Formula-Cookbook# https://rubydoc.brew.sh/Formula# PLEASE REMOVE ALL GENERATED COMMENTS BEFORE SUBMITTING YOUR PULL REQUEST!class Ybox &lt; Formula desc \"Missing toolchain for mobile development\" homepage \"https://github.com/liam-i/ybox\" url \"https://github.com/liam-i/ybox/archive/refs/tags/20240404.tar.gz\" sha256 \"4110b9414ea161f1c274c06389484f33168052590ead1fecf4f0f4b4468eaf10\" license \"Copyright © 2016 - 2024 Liam's Li. All Rights Reserved.\" version \"0.1.6\" # 列出软件包的依赖项 # depends_on \"cmake\" =&gt; :build def install # 这里写安装过程的命令，例如将可执行文件复制到 bin 目录。(因为这里下载的是个二进制包，所以直接填上 ybox 即可) bin.install \"ybox\" # system \"cmake\", \"-S\", \".\", \"-B\", \"build\", *std_cmake_args end # 可选的测试块，用于在安装后验证软件包的功能 test do system \"#{bin}/ybox\", \"--version\" # 举例的命令，应根据实际情况修改 endend测试 Formula语法检查 audit audit [options] [formula|cask …]检查 formula 是否违反 Homebrew 的编码风格。在提交 formula 和 cask 之前，应该运行此命令。如果没有指定 formula|cask，检查本地可用的所有 formula 和 cask，并跳过样式检查。如果发现任何错误，将以非零状态退出。详细教程brew audit --strict &lt;formula&gt; # 检查你的 Formula 是否符合 Homebrew 的规范和要求安装测试在本地环境中使用以下命令安装测试你的 Formula 是否能正确安装软件包。确保所有依赖项都已正确解决。brew install &lt;formula&gt;brew install &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 用完整路径，避免冲突如果遇到任何问题，可以使用 --debug 参数查看详细信息。例如：brew install --debug &lt;formula&gt;。在我们的案例中，需要执行 brew install liam-i/tap/ybox 来安装软件包。功能测试安装完成后，测试软件包的功能是否正常工作。这取决于你的软件包具体提供了什么功能。卸载测试功能测试完毕后，使用以下命令来卸载你的软件包。确保卸载过程没有遗留文件或配置。brew uninstall &lt;formula&gt;brew uninstall &lt;user&gt;/&lt;repo&gt;/&lt;formula&gt; # 用完整路径，避免冲突发布 Tap当你对你的 Formula 感到满意，并且所有测试都通过后，你可以考虑将你的 Tap 发布到 GitHub 或其他代码托管平台上，以便其他人也可以使用你的软件包。 我们在 创建-tap 阶段已经生成好了 Tap 的 Git 存储库。截止 测试-formula 完成，我们也准备好了 formulae。 接着，我们只需要把它与代码平台关联 (参考: 远程仓库 和 多人协作)，并推送到平台服务即可。 代码平台可以是 GitHub、GitLab 或者是 Gitee 等等。接着你自己或者其他人就可以远程添加我们的 Tap 仓库，并安装 Tap 里的 formulae 进行使用了。点击这里可以查看 如何使用 Homebrew Tap？维护 Tap随着时间的推移，你可以更新和扩展你的 Tap，添加更多的软件包或更新现有的软件包。 Tap 只是一个 Git 存储库，因此除了提交和推送更改之外，你在进行修改时无需执行任何特定操作。 安装 Tap 后，每次用户运行 brew update 时，Homebrew 都会对其进行更新。当用户运行 brew upgrade 时，过时的 formulae 将被升级，就像 Homebrew/Core 里的 formulae 一样。发布 Tap 仓库到 Homebrew/Core将你的 Tap 添加到 homebrew/core 仓库通常意味着你的软件包将被更多用户所使用。然而，这通常是一个复杂且需要社区认可的过程。如果你有这个需求请查看 Formula Cookbook 和 Adding Software to Homebrew。 注意：添加到 Homebrew/Core 需要满足一定的质量标准，并且可能需要与其他维护者进行多次沟通。优势与特点 扩展性：通过 Taps，用户可以访问到更多的软件包资源。 灵活性：用户可以根据自己的需求自由地添加、移除和管理 Taps。 社区支持：开源社区和许多项目都通过维护自己的 Taps 来分发软件，便于用户安装。注意事项 安全性：在添加 Tap 之前，请确保来源可信，避免添加不明来源的 Tap 以防止潜在的安全风险。 依赖管理：在安装 Tap 中的软件包时，请注意软件包之间的依赖关系，确保系统环境的稳定性。 更新策略：定期检查并更新 Taps 和其中的软件包，以保持系统的最新状态。结语Homebrew Tap 让 macOS 用户能按需定制自己的软件库。学会用 Homebrew Tap，能更高效地管理软件环境，为各种用途提供便利。所以，不妨试试 Homebrew Tap，酿造个性化的 macOS 软件库吧！如果想了解如何使用 Homebrew 轻松安装和管理 UNIX 工具和软件包，请查阅 Homebrew 酿酒术：精心调配你的 macOS 软件环境。相关链接 Taps (Third-Party Repositories) Can I edit formulae myself? How to Create and Maintain a Tap The complete API Homebrew 酿酒术：精心调配你的 macOS 软件环境 注意： 截止本文发布时 (2024-04-04)，Homebrew 版本为 4.2.16，本文所有案例都实践在此版本下。" }, { "title": "Homebrew 酿酒术：精心调配你的 macOS 软件环境", "url": "/posts/brew/", "categories": "工具, Homebrew", "tags": "Homebrew", "date": "2023-12-23 23:56:18 +0800", "snippet": "Homebrew 意为“家酿”，是一款用 Ruby 开发的包管理器。它像酿酒一样，让用户轻松“酿造”和管理软件环境，无需担心复杂的配置。通过 Homebrew，用户可以轻松安装、更新和卸载 UNIX 工具和软件包，实现个性化软件管理。目前支持 macOS 和 Linux 系统。在本文中，将详细介绍 Homebrew 的安装/卸载、模块组成、术语、常用命令等，助你快速上手，并优化你的 macO...", "content": "Homebrew 意为“家酿”，是一款用 Ruby 开发的包管理器。它像酿酒一样，让用户轻松“酿造”和管理软件环境，无需担心复杂的配置。通过 Homebrew，用户可以轻松安装、更新和卸载 UNIX 工具和软件包，实现个性化软件管理。目前支持 macOS 和 Linux 系统。在本文中，将详细介绍 Homebrew 的安装/卸载、模块组成、术语、常用命令等，助你快速上手，并优化你的 macOS (或 Linux) 软件环境。安装Homebrew 官网的安装说明位于主页，推荐复制粘贴官网的安装命令。macOS 环境要求 64-bit Intel CPU 或 Apple Silicon CPU macOS Monterey 12.0 或更高版本 Xcode 的命令行工具 (CLT)，可通过 xcode-select --install 或 developer.apple.com 或 Xcode 安装 为了安装，我们需要 Bourne-again shell (bash)命令行安装需要命令行安装可在终端执行以下命令：/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"该脚本会将 Homebrew 安装到默认的路径： macOS ARM: /opt/homebrew macOS Intel: /usr/local Linux: /home/linuxbrew/.linuxbrewHomebrew 安装完成后，当你进行 brew install 和其他命令时，不需要使用 sudo。因为 sudo 很危险。 注意：👉👉👉 查看更多安装方式点击这里 👈👈👈 .pkg 安装 如果使用 macOS，可以下载 .pkg 安装，下载地址：Homebrew’s latest GitHub release macOS .pkg 安装器会将 Homebrew 安装到默认的路径： macOS ARM: /opt/homebrew macOS Intel: /usr/local Git 镜像安装 如果连接到 GitHub.com 时遇到问题，可以使用 Git 镜像进行 Homebrew 安装和 brew update，方法是使用以下脚本在 shell 环境中设置 HOMEBREW_BREW_GIT_REMOTE 和 HOMEBREW_CORE_GIT_REMOTE: export HOMEBREW_BREW_GIT_REMOTE=\"...\" # 设置 Homebrew/brew 的 Git 镜像export HOMEBREW_CORE_GIT_REMOTE=\"...\" # 设置 Homebrew/homebrew-core 的 Git 镜像/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 如果未设置相应的环境变量，则将使用默认的 Git 远程仓库。 推荐几个镜像站：优化使用体验 无人值守安装 如果需要非交互式安装 Homebrew 而不提示输入密码 (例如在自动化脚本中)，可在安装命令前添加 NONINTERACTIVE=1 NONINTERACTIVE=1 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 解压到任何地方安装（不支持） 从技术上讲，你可以将 Homebrew 仓库下载 (或 git clone) 到任何地方安装。虽然官方不支持这样做，但还是给出了安装教程，如果需要请查看 Untar anywhere (unsupported)。 下载 安装脚本 并运行 /bin/bash install.sh --help 可以查看更多安装选项。 更新升级 Homebrew 可使用 brew update 命令。 卸载卸载 Homebrew 需要在终端执行以下命令：/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\"如果需要以非交互方式卸载 Homebrew (例如在自动化脚本中)，可在卸载命令前添加 NONINTERACTIVE=1NONINTERACTIVE=1 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/uninstall.sh)\" 下载 卸载脚本 并运行 /bin/bash uninstall.sh --help 可以查看更多卸载选项。 如果 .zshrc 或 .bash_profile 配置有环境变量需要手动删除。例如：HOMEBREW_BOTTLE_DOMAIN。删除完成后，执行：source ~/.zshrc 或 source ~/.bash_profile。模块组成Homebrew 作为一款广受欢迎的包管理工具，为 macOS 和 Linux 用户提供了一个简洁且高效的方式来安装、更新、卸载和管理各种软件包。以下是 Homebrew 最新版本的模块组成：核心模块 brew 功能：Homebrew 的主要命令行工具，用于与用户进行交互。 描述：它提供了软件包的安装、卸载、更新、查询等核心功能。用户通过 brew 命令可以轻松地管理他们的软件包。 homebrew-core 功能：Homebrew 的核心软件仓库。 描述：这个仓库包含了大量常用的软件包，每个软件包都有一个对应的 Formula（安装脚本），定义了软件的获取、编译和安装过程。 扩展模块 homebrew-cask 功能：专门用于安装和管理 macOS 上的图形界面应用程序。 描述：这个仓库包含了大量常用的 Cask（安装脚本），允许用户通过简单的命令安装和管理各种 macOS 图形应用程序。 homebrew-bottles 功能：提供了预编译软件包（称为“瓶子”）的存储和管理功能。 描述：这些预编译的软件包，可以让用户避免从源代码编译软件的繁琐步骤，从而加快软件的安装速度。homebrew-bottles 为用户提供了一个快速获取和使用预编译软件包的途径。 注意：homebrew-bottles 不是一个独立的仓库，虽然没有在 GitHub 集中管理，但你可以在 Homebrew 的官方网站上找到相关信息。 辅助工具与扩展 homebrew-services 功能：提供了一套管理工具，用于控制和管理通过 Homebrew 安装的服务。 描述：这个工具使得用户可以轻松地启动、停止、重启或查看通过 Homebrew 安装的服务的状态，如数据库、Web 服务器等。它简化了服务的管理过程，提高了用户的工作效率。 homebrew-cask-versions 功能：允许用户安装和管理特定版本的 macOS 图形界面应用程序。 描述：这个扩展为用户提供了安装旧版应用程序的能力，满足了用户对特定版本软件的需求。 注意：随着 Homebrew 的更新，此功能已整合到 homebrew-cask 中。 术语Homebrew 命名灵感来源于酿酒工艺，且使用的术语也与酿酒紧密相连。下面是我们对一些关键术语的解析： formula (配方): 描述：formula 定义了包的安装方法、源代码位置、依赖关系以及如何编译和安装。用户通过 brew install &lt;formula&gt; 命令，即可根据“配方”自动下载、编译并安装包。 示例：/opt/homebrew/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/f/foo.rb 酿酒术：“配方”决定酒的原料和酿造方法。 cask (木桶): 描述：cask 是一个扩展，用于安装和管理 macOS 上的图形界面程序。用户通过 brew install --cask &lt;cask&gt; 命令，即可自动下载、安装应用程序。 示例：/opt/homebrew/Homebrew/Library/Taps/homebrew/homebrew-cask/Casks/b/bar.rb 酿酒术：“木桶”用于存放和陈化葡萄酒。 prefix (前缀): 描述：prefix 指的是 Homebrew 安装路径，用户通过 brew --prefix 命令，即可查看。它提供了一个集中的安装环境，确保了软件包的组织性和一致性。 示例：/opt/homebrew 酿酒术：“前缀”指的是酒窖的区域。 keg (小桶): 描述：keg 用于存放给定版本的 formula 目录。 示例：/opt/homebrew/Cellar/foo/0.1 酿酒术：“小桶”是用来存放酒的容器。 rack (酒架): 描述：是指存放所有 kegs 的目录。 示例：/opt/homebrew/Cellar/foo 酿酒术：“酒架”用于摆放酒瓶。 keg-only (仅限桶装): 描述：如果一个 formula 没有符号链接到 Homebrew’s prefix 中，那么它就是 keg-only。 示例：openjdk formula opt prefix (选择前缀): 描述：已安装软件包的符号链接目录，方便访问。指向 keg 的 active 版本的符号链接。 示例：/opt/homebrew/opt/foo Cellar (酒窖): 描述：Cellar 是 Homebrew 的核心存储区域，存储所有已安装包的地方。也就是 rack 的安装目录。 示例：/opt/homebrew/Cellar 酿酒术：酿酒中，“酒窖”是存放和陈化酒的地方。 Caskroom (木桶间): 描述：存放和管理 cask 包的目录 示例：/opt/homebrew/Caskroom 酿酒术：酿酒中，“木桶间”是存放和管理木桶的地方。 tap (水龙头): 描述：tap 代表第三方软件包仓库 (通常是 Git 存储库)。通过 tap，用户可以添加第三方仓库，从而扩展 Homebrew 的软件包来源。 示例：/opt/homebrew/Homebrew/Library/Taps/homebrew/homebrew-core 酿酒术：酿酒中，“水龙头”用于从酒桶中取出酒液。 bottle (瓶装): 描述：bottle 允许用户直接下载和安装已经编译好的二进制包，无需从源代码开始编译，大大加快了安装速度。 示例：qt--6.5.1.ventura.bottle.tar.gz 酿酒术：酿酒中，“瓶装”指的是已经瓶装好，可直接销售的美酒。 相关链接：Manpage Terminology, Cookbook Terminology常用命令 有关完整的命令列表，请查看 COMMANDS 概要： brew --versionbrew command [--verbose|-v] [options] [formula|cask] … formula 或 cask 通常是要安装的软件包名称。它还有更多语法，请看 SPECIFYING FORMULAE 或 SPECIFYING CASKS 安装包 install install [options] formula|cask […]安装一个 formula 或 cask。详细教程brew install wget # 先尝试安装 formula，没有的话再尝试安装 cask 软件包brew install --formula wget # 指定安装一个 formula 软件包brew install --cask firefox # 指定安装一个 cask 软件包brew install --verbose --debug wget # 安装失败时使用这条指令重新安装，查看错误信息重新安装包 reinstall reinstall [options] formula|cask […]重新安装 formula 或 cask，如果之前有安装过，先卸载再安装。详细教程brew reinstall wget # 重新安装 wget，软件包选择顺序先 formula 再 caskbrew reinstall --formula wget # 重新安装 formula 软件包brew reinstall --cask firefox # 重新安装 cask 软件包卸载包 uninstall, remove, rm uninstall, remove, rm [options] installed_formula|installed_cask […]卸载一个 formula 或 cask。详细教程brew uninstall wget # 卸载本地已经安装的软件包brew uninstall --formula wget # 卸载本地已安装的 formula 软件包brew uninstall --cask firefox # 卸载本地已安装的 cask 软件包brew unistall wget --force # 彻底卸载已安装包的所有版本，并且在删除文件时忽略错误已安装的包 list, ls list, ls [options] [installed_formula|installed_cask …]列出所有已安装的 formula 和 cask。详细教程brew list # 查看所有已安装的软件包名称，包括 formula 和 caskbrew list wget # 查看已安装的软件包 wget 的文件信息brew list --formula # 查看所有已安装的 formula 软件包名称brew list --formula wget # 查看已安装的软件包 wget 的文件信息brew list --cask # 查看所有已安装的 cask 软件包名称brew list --cask firefox # 查看已安装的软件包 firefox 的文件信息brew list --version # 查看所有已安装的软件包的名称及版本信息brew list --version wget # 查看已安装的软件包 wget 的名称及版本信息搜索包 search search, -S [options] text|/regex/ […]对 cask 和 formula 执行搜索。如果 text 两侧有/，则它被解释为正则表达式。搜索范围在本地和远程，已安装会显示绿色的勾。详细教程brew search wget # 搜索本地远程仓库的软件，已安装会显示绿色的勾brew search /wget/ # 使用正则表达式搜软件brew search --formula wget # 只搜索 formula 下的 wget 软件包brew search --cask firefox # 只搜索 cask 下的 firefox 软件包包信息 info, abv info, abv [options] [formula|cask …]查看已安装包的简要统计信息。如果有 formula 或 cask，则显示它的信息摘要。详细教程brew info # 可以统计出本地安装了多少个 formula 软件包，共有多少文件，占用多少空间brew info wget # 可以看到软件包的概况，比如它来源于哪里，构建工具是什么，依赖有哪些，和哪些软件包有冲突，近期的分析统计数据brew info --formula wgetbrew info --cask firefox打开官网 home, homepage home, homepage [--formula] [--cask] [formula|cask …]在浏览器中打开 formula 或 cask 的主页。如果不提供参数，则打开 Homebrew 自己的主页。详细教程brew home # 打开 Homebrew 官网brew home wget # 打开 wget 官网brew home --formula wget # 打开 wget 官网brew home --cask firefox # 打开 firefox 官网更新升级 update, up update, up [options]使用 git 从 GitHub 获取最新版本的 Homebrew 和所有 formulae 进行升级安装，并显示已过时的软件包。详细教程brew update # 升级 Homebrew，并显示已过时的软件包已过时的包 outdated outdated [options] [formula|cask …]查看本地已安装，且版本已过时的 formulae 和 casks。详细教程brew outdated # 查看已经过时的软件包brew outdated wget # 查看已经过时的 wget 包brew outdated --formula # 查看所有已经过时的 formula 包brew outdated --formula wget # 查看 wget 是否已过时brew outdated --cask # 查看所有已经过时的 cask 包brew outdated --cask firefox # 查看 firefox 是否已过时升级包 upgrade upgrade [options] [installed_formula|installed_cask …]升级已过时的 cask 和过时的、未固定的 formula。如果指定了 cask 或 formula，则仅升级给定的 cask 或 formula kegs (除非它们已固定；请查看 pin、unpin)。详细教程如果未设置 HOMEBREW_NO_INSTALL_CLEANUP，升级完成后会自动执行 brew cleanup。brew upgrade # 更新所有已过时的软件包brew upgrade wget # 更新指定的 wget 软件包brew upgrade --formula wget # 更新指定的 wget 软件包brew upgrade --cask firefox # 更新指定的 firefox 软件包固定 pin pin installed_formula […]固定指定的 formula，防止在发出 brew upgrade formula 命令时升级它们。取消固定请查看 unpin。详细教程brew pin wget # 禁止升级 wget 注意：依赖于更新版本的固定 formula 的其他软件包可能无法正确安装或运行。取消固定 unpin unpin installed_formula […]取消固定 formula，允许它们通过 brew upgrade formula 进行升级。固定请查看 pin。详细教程brew unpin wget # 解除禁止升级 wget 的限制清理 cleanup cleanup [options] [formula|cask …]删除所有 formula 和 cask 的陈旧的锁文件和过时的下载，并删除已安装 formula 的旧版本。如果指定了参数，则仅对给定的 formula 和 cask 执行此操作。详细教程 注意： 默认会删除所有超过 120 天的下载。这可以通过 HOMEBREW_CLEANUP_MAX_AGE_DAYS 进行调整 如果被清理的软件包不是最新版本，Homebrew 会给出警告，这个警告可忽略 $ zstd --version*** Zstandard CLI (64-bit) v1.5.5, by Yann Collet ***$ brew cleanup zstdWarning: Skipping zstd: most recent version 1.5.6 not installed brew cleanup # 针对所有已安装软件包执行清理动作brew cleanup -n # 显示要删除的内容，但实际上不删除任何内容brew cleanup wget # 针对已安装的 wget 执行清理动作brew cleanup --formula wget # 针对已安装的 wget 执行清理动作brew cleanup --cask firefox # 针对已安装的 firefox 执行清理动作体检 doctor, dr doctor, dr [--list-checks] [--audit-debug] [diagnostic_check …]检查你的系统是否存在潜在问题。如果发现任何潜在问题，将以非零状态退出。详细教程brew doctor # 检查系统是否存在潜在问题帮助 help help [command …]输出 brew command 的使用说明。相当于 brew --help command。详细教程brew --help # 显示 brew 命令的使用说明brew --help info # 显示 info 命令的使用说明日志 log log [options] [formula|cask]显示 formula or cask 的 git log，如果没有指定 formula or cask，则显示 Homebrew 存储库的日志。详细教程brew log # 显示 Homebrew 存储库的日志brew log --formula # 显示 formula 存储库的日志配置信息 config config, --config显示对调试有用的 Homebrew 和系统配置信息。如果你提交错误报告，将需要提供这些信息。详细教程brew config # 显示 Homebrew 和 macOS 系统配置信息路径 --cache, --caskroom, --cellar, --env, --prefix, --repo --cache [options] [formula|cask …]显示 Homebrew 的下载缓存。如果指定了 formula，则显示用于缓存 formula 的文件或目录。详细教程 注意： Homebrew 使用 HOMEBREW_CACHE 目录作为下载缓存。默认： macOS: $HOME/Library/Caches/Homebrew Linux: $XDG_CACHE_HOME/Homebrew 或 $HOME/.cache/Homebrew brew --cache # 显示 Homebrew 的下载缓存路径brew --cache wget # 显示 wget 的下载缓存路径 --caskroom [cask …]显示 Homebrew 的 Caskroom 路径。如果指定了 cask，则显示 Caskroom 中 cask 的安装位置。详细教程brew --caskroom # 显示 Homebrew's Caskroom 路径 --cellar [formula …]显示 Homebrew 的 Cellar 路径。默认值： $(brew --prefix)/Cellar，如果该目录不存在，则为 $(brew --repository)/Cellar。如果指定了 formula，则显示 Cellar 中 formula 的安装位置。详细教程brew --cellar # 显示 Homebrew's Cellar 路径 --env, environment [--shell=] [--plain] [formula …]显示 Homebrew 的构建环境。详细教程brew --env # 显示 Homebrew 的构建环境 --prefix [--unbrewed] [--installed] [formula …]显示 Homebrew 的安装路径。默认： macOS ARM: /opt/homebrew macOS Intel: /usr/local Linux: /home/linuxbrew/.linuxbrew如果指定了 formula，则显示 formula 已安装或将要安装的位置。详细教程brew --prefix # 显示 Homebrew 安装路径 --repository, --repo [tap …]显示 Homebrew 的 Git 存储库所在的位置。如果指定了 user/repo，则显示 tap user/repo 的目录所在位置。详细教程brew --repo # 显示 Homebrew 本地的 Git 仓库版本 --version, -v --version, -v显示 Homebrew、Homebrew/homebrew-core 和 Homebrew/homebrew-cask (tap) 的版本号。详细教程brew --version # 显示 Homebrew 版本优化使用体验对于国内用户来说，优化 Homebrew 的使用体验主要需要解决网络问题，因为 Homebrew 的默认源位于国外，可能会受到网络访问限制或速度慢的影响。 国内镜像源： 可以将源站切换到国内镜像，从而加速下载和更新。 推荐几个国内 Homebrew 镜像站： 阿里云官方镜像站 腾讯软件源 中国科学技术大学开源软件镜像 清华大学开源软件镜像站 北京外国语大学开源软件镜像站 Hosts 加速： 通过 www.ipaddress.com 查询 raw.githubusercontent.com 对应 IP 地址，然后添加到 /etc/hosts 文件中。 设置 DNS 服务，如果默认用的国内 DNS 服务，可能存在污染。可以换到 Google Public DNS。 配置完成之后再执行安装和更新操作。 手动查询 Github 相关 IP 地址会比较麻烦，这里推荐一个仓库，里面提供了最新的 GitHub Hosts 地址。然后再推荐使用 SwitchHosts 进行 hosts 管理会比较简单，这里查看详细 使用说明。 代理或 VPN： 可以使用代理服务器或 VPN 来加速资源的访问。但请注意，使用代理或 VPN 可能涉及法律风险，请确保你的使用方式合法。 定期清理和更新： 定期使用 brew cleanup 清理旧版本，以及使用 brew update 和 brew upgrade 更新 Homebrew 和已安装的软件包。 注意事项在使用 Homebrew 时，有几点需要注意： 确保你的 macOS 系统版本与 Homebrew 兼容。 定期运行 brew update 以保持 Homebrew 和 formula 的最新版本。 定期使用 brew doctor 检查系统环境。 当安装新软件包时，注意检查其依赖关系以避免潜在的冲突。 对于 Keg-only 的软件包，需要使用特定的命令来调用它们。结语Homebrew 是个强大的包管理器，也是一个蕴含酿酒文化的艺术品。学会使用 Homebrew，你能精细管理你的 macOS 软件环境，提升效率，增添乐趣。希望本文能助你更深入理解和使用 Homebrew，享受自制软件的快乐！如果想了解如何使用 Homebrew Tap 访问第三方仓库或定制个人软件库，请查阅 Homebrew Tap：酿造你的个性化 macOS 软件库。相关链接 https://brew.sh https://github.com/ruby/ruby brew manual page (command documentation) brew installation Formula Cookbook Homebrew Tap：酿造你的个性化 macOS 软件库 注意： 截止本文发布时 (2023-12-23)，Homebrew 版本为 4.2.0，本文所有案例都实践在此版本下。" }, { "title": "Git 常用命令思维导图", "url": "/posts/git-cmd/", "categories": "工具, git", "tags": "git", "date": "2023-11-18 20:36:18 +0800", "snippet": "Git 是 Linux 作者 Linus 的一个作品。2002 年他还在使用 Bitkeeper 作为 Linux 内核的版本管理，但因为它是 Copyright 有版权的软件备受质疑，然后 Andrew Tridgell 对 Bitkeeper 进行逆向工程，导致 BitMover 要回收 Linux 开发者的 Bitkeeper 的免费使用权，Linus 一怒之下花了 10 天写出了 G...", "content": "Git 是 Linux 作者 Linus 的一个作品。2002 年他还在使用 Bitkeeper 作为 Linux 内核的版本管理，但因为它是 Copyright 有版权的软件备受质疑，然后 Andrew Tridgell 对 Bitkeeper 进行逆向工程，导致 BitMover 要回收 Linux 开发者的 Bitkeeper 的免费使用权，Linus 一怒之下花了 10 天写出了 Git。如今 Git 已经成为绝大多数开发者的选择，Tom Preston-Werner、Chris Wanstrath 和 PJ Hyett 在 2007 年 10 月推出的 Github 已经成为了全球最大的开发者网站。代码仓库创建仓库 进入需要创建代码库的文件夹：cd 文件路径 创建/初始化仓库：git init 拉取远程仓库到本地：git clone 建议使用 git clone添加文件到仓库 添加文件到暂存区 添加单个文件变化：git add 添加所有文件：git add . 会忽略的文件 .gitignore 中指定的文件会被忽略 空目录 提交到本地仓库：git commit -m \"commit message\" 不建议使用 git commit -m \"commit message\" 建议提交遵循 commit message 规范。例如：Angular 的 Git Commit Guidelines 查看工作区状态：git status 对比工作区文件变化：git diff 建议将 beyond compare 配置为 diff 工具，用于 diff 以及 merge 冲突 仓库配置 配置全局用户名和邮箱 git config --global user.name \"[name]\" 比如：git config --global user.name \"liam-i\" git config --global user.email \"[email address]\" 注意：若是个人开发机可以这样配置，若是公共编译机则不能这样配置 配置当前仓库的用户名和邮箱 git config user.name \"[name]\" git config user.email \"[email address]\" 代码版本/提交切换查看过去版本/提交 提交详情：git log 提交简介：git log --pretty=oneline回退版本/提交 回退到当前最新提交：git reset --hard HEAD 回退到上次提交：git reset --hard HEAD^ 回退到上 n 次提交：git reset --hard HEAD～n 回退到某次提交：git reset --hard commitid重返未来版本 查看历史提交以及被回退的提交：git relog 注意：该记录有时限，且只在本地 回到未来版本：git reset --hard commitid撤销修改 工作区文件被撤销（没有提交到暂存区/没有 git add）撤销修改：git checkout 文件名 暂存区文件撤销 将暂存区文件撤销到工作区：git reset HEAD 文件 # 不带 --hard 撤销修改：git checkout 文件名 提交到了版本库，参见回退版本/提交删除文件 从版本库中删除文件：git rm 文件名 恢复删除，参见撤销修改 从版本库中删除文件，但是本地不删除该文件：git rm --cached 文件名暂存修改参见分支-暂存修改忽略文件通过 git 仓库下的 .gitignore 文件屏蔽某些中间文件/生成文件 注意：这里的版本均为本地仓库版本分支创建与操作分支 创建分支 仅创建：git branch 分支名 创建并切换：git branch -b 分支名 或 git switch --create 分支名 注意：在本地仓库操作，创建的都是本地分支 切换分支：git checkout 分支名 或 git switch 分支名 合并分支 git merge 分支名 合并某分支到当前分支 注意：合并分支时禁用 fast forward，git merge --no-ff 分支名 git rebase 若无特殊需求不建议使用 删除分支 删除本地分支 删除未合并分支：git branch -D 分支名 删除已合并分支：git branch -d 分支名 删除远程分支 删除远程分支 git push origin -d 分支名 git push &lt;远程仓库名&gt; -d 分支名 建议界面操作 查看分支 查看当前分支：git branch 查看所有分支信息：git branch -a 本地分支为本地分支名，远程分支为/分支名 合并分支，解决冲突 将要合并的分支更新到最新 切换到 main 分支 合并分支 解决合并时的 conflict 提交到版本库 合并成功 查看分支状态 git log --graph git log --graph --pretty=oneline --abbrey-commit 开发完需要提交 PR/MR，通过 PR/MR 来合并 dev 分支与 main 分支暂存修改 暂存工作现场：git stash 恢复工作现场 恢复：git stash apply 删除：git stash drop 恢复+删除：git stash pop 多人协作 查看远程库信息 详细：git remote -v 不详细：git remote 删除/关联/修改远程仓库地址 删除：git remote rm 远程仓库名 例如：git remote rm origin 关联：git remote add origin 远程仓库地址 修改：git remote set-url origin 新的远程仓库地址 更新/推送远程库 更新远程库信息：git fetch 将远程库最新修改更新到本地：git pull 可以认为是 git fetch + git merge 将本地修改推送到远程库 git push git push origin 分支名 本地分支与远程分支交互 使用远程分支 A 创建本地分支 git checkout -b A origin/A，origin 是远程仓库名，若名字一样 origin/A 可以省略 将本地分支与远程分支作关联 git branch --set-upstream A origin/A 提示 no tracking information 错误 建议开发遵循或者参照 git 标准工作流，比如 git flow、github flow 或者 gitlab flow代码标签 查看 tag 本地 tag：git tag 远程 tag：git tag -r 操作 tag 添加 tag 给当前版本添加 tag：git tag 标签名 给历史版本添加 tag：git tag 标签名 commitid 删除 tag 删除本地 tag：git tag -d 标签名 删除远程 tag：git push origin -d 标签名 推送到远端仓库 git push origin 标签名 推送所有未提交的 tag：git push origin --tags 更新到本地：git pull origin --tags tag 与 branch 的操作基本一致，因为 tag 就是一个仅可读的 branch其他生僻命令 git blame，用来追溯一个指定文件的历史修改记录 git bisect，过二分查找定位引入 bug 的变更 git relog，查看历史提交以及被回退的提交 可以使用 git help 查看 git 常用的命令，使用 git help -a 查看 git 可用的所有命令 可以点击 Documentation 查看 git 官方文档 思维导图Git 常用命令思维导图参考链接 原文地址：Git 常用命令思维导图。注：顶部预览图也来自此地址。" }, { "title": "使用 VuePress 搭建博客", "url": "/posts/blog-vuepress/", "categories": "前端", "tags": "前端, 博客", "date": "2022-10-15 22:55:00 +0800", "snippet": "VuePress 是一个以 Markdown 为中心的静态网站生成器。你可以使用 Markdown 来书写内容（如文档、博客等），然后 VuePress 会帮助你生成一个静态网站来展示它们。VuePress 官网文档已经写的非常好了。我写这篇文档的目的只是记录自己用 VuePress 1.x 搭建一个博客的全过程。如果你阅读这篇文档，它将教你如何简单直接一步一步的搭建一个博客。请阅读 Vue...", "content": "VuePress 是一个以 Markdown 为中心的静态网站生成器。你可以使用 Markdown 来书写内容（如文档、博客等），然后 VuePress 会帮助你生成一个静态网站来展示它们。VuePress 官网文档已经写的非常好了。我写这篇文档的目的只是记录自己用 VuePress 1.x 搭建一个博客的全过程。如果你阅读这篇文档，它将教你如何简单直接一步一步的搭建一个博客。请阅读 VuePress 官网文档 v1.x， v2.x。为什么选择 VuePress经过调研，简单了解了一下几个博客： GitBook: 如今的 GitBook 更加偏向于商业化，而开源版已经几年没维护了。 Nuxt: 是为构建应用程序而生的，而 VuePress 则专注于以内容为中心的静态网站上。 Docsify: 完全的运行时驱动，因此对 SEO 不够友好。vuepress 特性 内置的 Markdown 拓展 在 Markdown 中 使用 Vue Vue驱动的自定义主题系统 自动生成Service Worker(支持PWA) 强大的 Plugin API 基于Git的”最后更新时间项目搭建 前提条件:VuePress 需要 Node.js &gt;= 8.6 创建并进入一个新目录 mkdir MyBlog &amp;&amp; cd MyBlog 使用你喜欢的包管理器进行初始化 yarn init # npm init 初始化完成后会创建一个 package.json 文件 { \"name\":\"blog\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\"} 在 package.json 中添加一些 scripts，这些命令将用于启动服务器 \"scripts\": { \"docs:dev\": \"vuepress dev docs\", \"docs:build\": \"vuepress build docs\" } 启动服务: yarn docs:dev 编译打包: yarn docs:build 将 VuePress 安装为本地依赖 yarn add -D vuepress # npm install -D vuepress 不再推荐全局安装 VuePress 如果你的现有项目依赖了 webpack 3.x，推荐使用 Yarn 而不是 npm 来安装 VuePress。因为在这种情形下，npm 会生成错误的依赖树 创建你的第一篇文档 mkdir docs &amp;&amp; echo '# Hello VuePress' &gt; docs/README.md docs 目录用于存放我们写的 .md 文档和 .vuepress 相关配置 在本地启动服务器 yarn docs:dev # npm run docs:dev VuePress 会在 http://localhost:8080 启动一个热重载的开发服务器。 基本配置配置文件为了让我们的网站更加丰富多彩，需要做一些配置，让我们创建一个 .vuepress 目录和 config.js 文件。cd docsmkdir .vuepress &amp;&amp; cd .vuepress &amp;&amp; touch config.js 这时你的项目结构可能是这样： .├─ docs│ ├─ README.md│ └─ .vuepress│ └─ config.js└─ package.json config.js 是一个 VuePress 网站必要的配置文件。它最基础的配置内容如下: module.exports = { title: '遥望的博客', description: '专注与iOS开发的一些技术分享'} 对于上述的配置，如果你运行起服务: yarn docs:dev 。应该看到以下页面： 默认主题配置首页默认的主题提供了一个首页的布局。想要使用它，需要在你的根级 README.md 写一些内容。以下是一个例子：---home: trueheroImage: /assets/cover.jpgheroText: 标题tagline: 副标题actionText: 快速上手 →actionLink: /ios/features:- title: 简洁至上 details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。- title: Vue驱动 details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。- title: 高性能 details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。footer: MIT Licensed | Copyright © 2020-present Yao wang--- 你可以将相应的内容设置为 null 来禁用标题和副标题。对于上述的配置，如果你运行起服务: yarn docs:dev 。应该看到以下页面：导航栏配置导航栏 Logo将Logo图标放置在 .vuepress/public/assets 目录，并在 config.js 中添加：// .vuepress/config.jsmodule.exports = { themeConfig: { logo: '/assets/logo.png', }}导航栏链接// .vuepress/config.jsmodule.exports = { themeConfig: { nav: [ { text: '首页', link: '/' }, { text: 'iOS', link: '/ios/' }, { text: '前端', link: 'frontend' }, { text: '关于', link: 'about' }, ] }}如果想要一个 下拉列表 ，可提供了一个 items 数组而不是一个单一的 link 如下：// .vuepress/config.jsmodule.exports = { themeConfig: { nav: [ { text: '首页', link: '/' }, { text: 'iOS', link: '/ios/' }, { text: '前端', link: '/frontend/' }, { text: '关于', link: '/about/' }, { text: '语言', items: [ { text: \"中文\", link:\"/language/chinese/\"}, { text: \"英语\", link:\"/language/english/\"} ] } ] }}此外，你还可以通过嵌套的 items 来在 下拉列表 中设置分组：// .vuepress/config.jsmodule.exports = { themeConfig: { nav: [ { text: '语言', items: [ { text: 'Group1', items: [/* */] }, { text: 'Group2', items: [/* */] } ] } ] }}对于上述的配置，如果你运行起服务: yarn docs:dev 。应该看到以下页面：禁用导航栏你可以使用 themeConfig.navbar 来禁用所有页面的导航栏：// .vuepress/config.jsmodule.exports = { themeConfig: { navbar: false }}你也可以在 README.md 里添加以下代码 来禁用某个指定页面的导航栏：---navbar: false---侧边栏配置侧边栏分组你可以在 config.js 里使用 对象 来将侧边栏划分成多个组：// .vuepress/config.jsmodule.exports = { themeConfig: { sidebar: [ { title: 'Group 1', // 必要的 path: '/foo/', // 可选的, 标题的跳转链接，应为绝对路径且必须存在 collapsable: false, // 可选的, 默认值是 true, sidebarDepth: 1, // 可选的, 默认值是 1 children: [ '/' ] }, { title: 'Group 2', children: [ /* ... */ ], initialOpenGroupIndex: -1 // 可选的, 默认值是 0 } ] }} 侧边栏的每个子组默认是可折叠的，你可以设置 collapsable: false 来让一个组永远都是展开状态。 一个侧边栏的子组配置同时支持 sidebarDepth 字段用于重写默认显示的侧边栏深度(1)。多个侧边栏如果你想为不同的页面组来显示不同的侧边栏，首先，将你的页面文件组织成下述的目录结构：.├─ README.md├─ about.md├─ foo/│  ├─ README.md│ ├─ one.md│ └─ two.md└─ bar/ ├─ README.md ├─ three.md └─ four.md接着，遵循以下的侧边栏配置：// .vuepress/config.jsmodule.exports = { themeConfig: { sidebar: { '/foo/': [ '', /* /foo/ */ 'one', /* /foo/one.html */ 'two' /* /foo/two.html */ ], '/bar/': [ '', /* /bar/ */ 'three', /* /bar/three.html */ 'four' /* /bar/four.html */ ], // fallback '/': [ '', /* / */ 'about' /* /about.html */ ] } }} 确保 fallback 侧边栏被最后定义。VuePress 会按顺序遍历侧边栏配置来寻找匹配的配置。自动生成侧栏你可以在 config.js 中配置 themeConfig.sidebar 来在所有页面中启用它：// .vuepress/config.jsmodule.exports = { themeConfig: { sidebar: 'auto' }}对于上述的配置，如果你运行起服务: yarn docs:dev 。应该看到以下页面：搜索框配置内置搜索框// .vuepress/config.jsmodule.exports = { themeConfig: { search: false, // 禁用默认的搜索框 searchMaxSuggestions: 10 // 调整默认搜索框显示的搜索结果数量 }}最后更新时间你可以通过 themeConfig.lastUpdated 选项来获取每个文件最后一次 git 提交的 UNIX 时间戳(ms)，同时它将以合适的日期格式显示在每一页的底部：// .vuepress/config.jsmodule.exports = { themeConfig: { lastUpdated: '上次更新', // string | boolean }} 由于 lastUpdated 是基于 git 的, 所以你只能在一个基于 git 的项目中启用它。此外，由于使用的时间戳来自 git commit，因此它将仅在给定页的第一次提交之后显示，并且仅在该页面后续提交更改时更新。上 / 下一篇链接上一篇和下一篇文章的链接将会自动地根据当前页面的侧边栏的顺序来获取。// .vuepress/config.jsmodule.exports = { themeConfig: { nextLinks: false, // 默认值是 true 。设置为 false 来全局禁用所有页面的 下一篇 链接 prevLinks: false // 默认值是 true 。设置为 false 来全局禁用所有页面的 上一篇 链接 }}Git 仓库和编辑链接当你提供了 themeConfig.repo 选项，将会自动在每个页面的导航栏生成生成一个 GitHub 链接，以及在页面的底部生成一个 \"Edit this page\" 链接。// .vuepress/config.jsmodule.exports = { themeConfig: { repo: 'liam-i/blog', // 假定是 GitHub. 同时也可以是一个完整的 GitLab URL repoLabel: 'GitHub', // 自定义仓库链接文字。默认从 `themeConfig.repo` 中自动推断 // 以下为可选的编辑链接选项 docsRepo: 'liam-i/blog', // 假如你的文档仓库和项目本身不在一个仓库： docsDir: 'docs', // 假如文档不是放在仓库的根目录下： docsBranch: 'master', // 假如文档放在一个特定的分支下： editLinks: true, // 默认是 false, 设置为 true 来启用 editLinkText: '帮助我们改善此页面！' // 默认为 \"Edit this page\" }}评论 Vssue 配置为什么选择 VssueVssue 的灵感来自于 Gitment 和 Gitalk，但是和它们有些区别： Vssue 支持 Github, Gitlab, Bitbucket, Gitee 和 Gitea，并且很容易扩展到其它平台。Gitment 和 Gitalk 仅支持 Github。 Vssue 可以发表、编辑、删除评论。Gitment 和 Gitalk 仅能发表评论。 Vssue 是基于 Vue.js 开发的，可以集成到 Vue 项目中，并且提供了一个 VuePress 插件。Gitment 基于原生JS，而 Gitalk 基于 Preact。创建 GitHub OAuth App 前往 Settings - Developer Settings - OAuth Apps 点击 New OAuth App 将 Homepage URL 和 Authorization callback URL 设置为你的网站 URL。示例如下图： 获取 Client ID 和 Secret现在你已经创建了一个新的 OAuth App，并得到了相应的 Client ID 和 Client Secret。如下图：安装 Vssue通过 NPM 安装 @vssue/vuepress-plugin-vssue 和你需要使用的 API 包 ：npm install @vssue/vuepress-plugin-vssuenpm install @vssue/api-github-v3配置 Vssue在 config.js 中填写如下配置。具体插件使用方法可参考 VuePress 官方文档// .vuepress/config.jsmodule.exports = { plugins: { '@vssue/vuepress-plugin-vssue': { platform: 'github', // 设置 `platform` 而不是 `api` locale: 'zh', // 本地化。如果你不设置 locale，Vssue 会自动使用 VuePress 的 $lang 作为当前页面的语言 owner: 'OWNER_OF_REPO', // 对应 repository 的拥有者帐号或者团队 repo: 'NAME_OF_REPO', // 用来存储评论的 repository clientId: 'YOUR_CLIENT_ID', // OAuth App 的 client id clientSecret: 'YOUR_CLIENT_SECRET', // OAuth App 的 client secret }, },};使用 Vssue 组件你可以在你的 Markdown 文件中直接使用它。&lt;!-- README.md --&gt;# 你自己写的 Markdown 文件 的内容&lt;Vssue :title=\"$title\" /&gt;对于上述的配置，如果你运行起服务: yarn docs:dev 。应该看到以下页面：Github 部署 下述的指南基于以下条件： 文档放置在项目的 docs 目录中； 使用的是默认的构建输出位置； VuePress 以本地依赖的形式被安装到你的项目中，并且在 package.json 中配置了如下代码: { \"scripts\": { \"docs:build\": \"vuepress build docs\" }} 创建 Github 仓库 在 github 上创建一个名为 blog 的仓库，并在 config.js 中配置base值为blog // .vuepress/config.jsmodule.exports = { base: '/blog/',} 在你的项目根目录中，创建一个如下的 deploy.sh 文件: #!/usr/bin/env sh# 确保脚本抛出遇到的错误set -e# 生成静态文件yarn docs:build# 进入生成的文件夹cd docs/.vuepress/dist# 如果是发布到自定义域名# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git main:gh-pagescd - 执行部署脚本 deploy.sh ./deploy.sh 上述脚本 deploy.sh 会在 GitHub 的 blog 仓库中创建一个名为 gh-pages 的分支，并将生成的静态文件提交到该分支下。 设置 GitHub Pages 在 blog 仓库下点击 Setting 按钮，找到 GitHub Pages - Source，然后选择 gh-pages 分支，点击 Save 按钮即可。👇👇👇下面是配置后的效果图：" }, { "title": "如何在多个 Git 平台玩转一个仓库", "url": "/posts/git-sync/", "categories": "工具, git", "tags": "git", "date": "2022-08-07 19:18:18 +0800", "snippet": "版本控制在软件开发中至关重要，而 Git 是广泛使用的代码管理工具。有时，我们可能需要在多个平台 (如 GitHub、GitLab 和 Gitee) 上同步同一 Git 仓库，以便备份、协作等。本文将带你玩转此操作，其中关键是“配置 SSH” 和“远程仓库”。首先，我们来讲述 SSH 的配置。配置 SSH为确保安全和简化登录，需配置 SSH 密钥。SSH 密钥是用于身份验证的安全方式，可免...", "content": "版本控制在软件开发中至关重要，而 Git 是广泛使用的代码管理工具。有时，我们可能需要在多个平台 (如 GitHub、GitLab 和 Gitee) 上同步同一 Git 仓库，以便备份、协作等。本文将带你玩转此操作，其中关键是“配置 SSH” 和“远程仓库”。首先，我们来讲述 SSH 的配置。配置 SSH为确保安全和简化登录，需配置 SSH 密钥。SSH 密钥是用于身份验证的安全方式，可免密访问远程 Git 仓库。检查现有 SSH 密钥在生成新的 SSH 密钥之前，应该检查本地电脑是否存在现有密钥。打开终端，输入一下命令以查看是否存在现有的 SSH 密钥。ls -al ~/.ssh此命令将列出 .ssh 目录中的所有文件（如果存在）。如果没有想要的，需要创建新的 SSH 密钥对。生成新 SSH 密钥在本地电脑上生成新的 SSH 密钥。 生成密钥后，可将公钥添加到 GitHub 等平台上的帐户中，以便通过 SSH 为 Git 操作启用身份验证。打开终端输入一下命令，然后一路 Enter 键，完成密钥对的生成：ssh-keygen -t ed25519 -C \"your_email@example.com\" -f ~/.ssh/id_github在这个命令中： ssh-keygen 用于生成、管理和转换认证密钥的工具。 -t 指定了密钥类型。ed25519 是一种现代的、安全的公钥加密算法，被广泛认为是非常强大且高效的。与 RSA 和 DSA 密钥相比，它提供了更好的安全性和性能。 -C 指定一个注释，通常是用户的电子邮件地址。 -f 指定了密钥文件的保存位置和名称。默认情况下，ssh-keygen 会生成名为 id_rsa、id_ed25519 等的文件，具体取决于所选的密钥类型。在这里，它将被保存为 ~/.ssh/id_github (私钥) 和 ~/.ssh/id_github.pub (公钥)。 相关链接： GitHub: 生成新 SSH 密钥 GitLab: 生成 SSH 密钥对 Gitee: 生成 SSH 公钥 编辑 ~/.ssh/config 文件为了在一台电脑上配置多个平台的 SSH，你需要编辑 ~/.ssh/config 文件。以下是一个配置示例，分别配置了 GitHub、GitLab 和 Gitee 的 SSH：# GitHub 配置Host github.com HostName github.com User git IdentityFile ~/.ssh/id_github PreferredAuthentications publickey,password # 优先使用 SSH 公钥认证，然后再尝试用户名和密码认证 IdentitiesOnly yes# GitLab 配置Host gitlab.com HostName gitlab.com User git IdentityFile ~/.ssh/id_gitlab PreferredAuthentications publickey # 仅使用 SSH 公钥认证 IdentitiesOnly yes# Gitee 配置Host gitee.com HostName gitee.com User git IdentityFile ~/.ssh/id_gitee PreferredAuthentications publickey # 仅使用 SSH 公钥认证 IdentitiesOnly yes在这个配置中： Host 是你定义的别名，可以随意命名，但通常使用服务域名以方便记忆。 HostName 是实际的服务域名。 User 通常是 git，因为这是大多数 Git 服务器的默认用户名。 IdentityFile 指向你的私钥文件路径。 PreferredAuthentications 指定 SSH 客户端在尝试身份验证时应优先考虑的认证方法列表。例如，你可以设置为只使用公钥认证，或者优先使用公钥认证，然后再尝试其他 (密码) 认证方式。 IdentitiesOnly yes 指示 SSH 只使用 IdentityFile 指定的身份进行认证，这有助于避免 SSH 代理或默认私钥的干扰。新增 SSH 密钥到平台帐户配置 ~/.ssh/config 文件完毕后，必须将 SSH 公钥添加到 GitHub、GitLab 和 Gitee，才能为帐户启用 SSH 访问。 相关链接： 新增 SSH 密钥到 GitHub 帐户 将 SSH 密钥添加到您的极狐 GitLab 帐户 添加 SSH 公钥到 Gitee 帐户 测试 SSH 连接设置 SSH 密钥并将其添加到 GitHub、GitLab 和 Gitee 后，可以测试连接。测试 SSH 连接之前，应已完成以下各项： 检查现有 SSH 密钥 生成新 SSH 密钥 编辑 ~/.ssh/config 文件 新增 SSH 密钥到平台帐户打开终端，输入以下命令：ssh -T git@github.com # 测试 Github 的 SSH 连接ssh -T git@gitlab.example.com # 测试 Gitlab 的 SSH 连接。注意：要将 gitlab.example.com 替换为你的实例 URLssh -T git@gitee.com # 测试 Gitee 的 SSH 连接如果这是你第一次连接，你应该会看到类似以下消息，提示你需要验证平台主机的真实性：&gt; The authenticity of host ' (IP ADDRESS)' can't be established.&gt; ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.&gt; Are you sure you want to continue connecting (yes/no)?输入 yes，然后按 Enter。&gt; Hi USERNAME! You've successfully authenticated, but GitHub does not&gt; provide shell access.添加成功后，就可以使用 SSH 协议访问这些平台了。例如，你可以使用 git clone git@github.com/username/repository.git 来克隆 GitHub 上的仓库，SSH 会根据 ~/.ssh/config 文件中的配置来选择合适的私钥进行身份验证。 相关链接： 测试 Github 的 SSH 连接 测试 Gitlab 的 SSH 连接 测试 Gitee 的 SSH 连接 我们为电脑配置完 SSH 后，接下来为本地 Git 仓库添加多个远程平台的仓库链接。配置远程仓库没有 Git 仓库为 Git 仓库添加多个远程平台的仓库的前提是得有个本地 Git 仓库。如果你还没有，可以用以下命令初始化一个。cd your_foldergit init --initial-branch=main已经有 Git 仓库如果你已经在其中一个平台上有个 Git 仓库，你可以使用以下命令将其克隆到本地。git clone &lt;远程仓库URL&gt;然后，cd 到新初始化、或者克隆下来的仓库目录，添加其他平台的远程仓库链接 🔗。查看远程仓库添加之前，我们先查看一下本地 Git 仓库是否有远程仓库的链接，在终端执行以下命令：git remote -v如果刚才是本地新初始化的 Git 仓库，不会有任何信息打印。但是，刚才是从远程平台克隆下来的，就会有以下信息打印。比如，我们是从 Github 克隆的。origin\tgit@github.com:liam-i/git-multi-platform-sync.git (fetch)origin\tgit@github.com:liam-i/git-multi-platform-sync.git (push)删除远程仓库为了明确指向多平台远程仓库，所以我们用以下命令删除不直观的 origin，稍后再添加一个具有明确指向性的别名。git remote remove origin添加远程仓库为了将本地仓库与其他平台的远程仓库关联起来，需要执行以下命令为它们添加别名。git remote add &lt;别名&gt; &lt;远程仓库URL&gt;例如，你可以为 GitHub 仓库添加别名 github，为 GitLab 仓库添加别名 gitlab：git remote add github git@github.com:liam-i/git-multi-platform-sync.gitgit remote add gitlab ssh://git@gitlab.com:liam-i/git-multi-platform-sync.gitgit remote add gitee git@gitee.com:liam-i/git-multi-platform-sync.git添加完成后，我们再用 git remote -v 命令查看一下：$ git remote -vgithub\tgit@github.com:liam-i/git-multi-platform-sync.git (fetch)github\tgit@github.com:liam-i/git-multi-platform-sync.git (push)gitlab\tssh://git@gitlab.com:liam-i/git-multi-platform-sync.git (fetch)gitlab\tssh://git@gitlab.com:liam-i/git-multi-platform-sync.git (push)gitee\tgit@gitee.com:liam-i/git-multi-platform-sync.git (fetch)gitee\tgit@gitee.com:liam-i/git-multi-platform-sync.git (push)同步操作推送代码当你对本地仓库进行了修改，并提交了新的更改后，可以使用以下命令将这些更改推送到所有远程平台：git push &lt;别名&gt; &lt;分支名&gt;例如，将更改推送到 GitHub、GitLab 和 Gitee：git push github maingit push gitlab maingit push gitee main拉取代码如果你想从某个远程仓库拉取最新的更改到本地，可以使用以下命令：git pull &lt;别名&gt; &lt;分支名&gt;例如，从 GitHub、GitLab 和 Gitee 拉取更改：git pull github maingit pull gitlab maingit pull gitee main 注意：在拉取代码之前，请确保你在正确的分支上，并且本地仓库的工作目录是干净的。管理与维护为了保持多个平台上的仓库数据一致性，你需要定期进行同步操作。同时，当在多个平台上进行协作时，注意解决可能出现的冲突。要解决冲突可以使用 git merge 工具，并确保在推送更改之前测试代码的完整性。 关于更详细的 Git 操作指令请参考： Git 常用命令思维导图 Git 一个先进的分布式版本控制系统 结语看完这篇博客，你应该已经知道怎么在多个平台上玩转 Git 仓库同步了。同步时别忘了多留个心眼，还要时不时确认下各平台的数据是否都对得上。希望你用 Git 越来越 6！🤙🤙🤙参考链接 https://git-scm.com 通过 SSH 连接到 GitHub 使用 SSH 密钥与极狐GitLab 通信 为 Gitee 生成、添加 SSH 公钥 Git 常用命令思维导图 Git 一个先进的分布式版本控制系统" }, { "title": "CocoaPods - 发布 podspec 到 repo", "url": "/posts/pod-push/", "categories": "工具, CocoaPods", "tags": "CocoaPods", "date": "2021-12-05 22:55:00 +0800", "snippet": "本篇文章我将通过一个名叫 FlyHUD 的开源组件来讲解如何提交 podspec 到共有 Specs Repo。验证组件名因为 Specs Repo 里的每个组件不能重名，所以我们在创建组件之前先验证一下组件名称是否已被使用。方法一：在 cocoapods.org 官网搜索组件名方法二：在终端输入一下命令pod search 组件名 # 例如：pod search FlyHUD创建代码仓库...", "content": "本篇文章我将通过一个名叫 FlyHUD 的开源组件来讲解如何提交 podspec 到共有 Specs Repo。验证组件名因为 Specs Repo 里的每个组件不能重名，所以我们在创建组件之前先验证一下组件名称是否已被使用。方法一：在 cocoapods.org 官网搜索组件名方法二：在终端输入一下命令pod search 组件名 # 例如：pod search FlyHUD创建代码仓库点击此链接将跳转到 Github 去创建一个 Public 代码仓库。创建组件工程如果你是现有的组件项目，并且在 Git 的版本管理下，那么这一步就算完成了，可以直接进行下一步了。如果你需要从零开始创建一个组件库，那么我建议你使用 Cocoapods 提供的一个工具将后两步结合起来做。这个工具详细使用说明请参考官网 Using Pod Lib Create，也可以查看 Github，它是一个开源工具。这里以 FlyHUD 为例，打开终端 cd 到要创建项目的目录然后执行：pod lib create FlyHUD之后他会问你五个问题： 选择创建 iOS 或 macOS 工程； 选择用 Swift 或 ObjC； 是否需要 demo 工程； 选择一个测试框架； 是否需要基于 View 测试。我这里选择的是 1. iOS；2. Swift；3. Yes；4. None；5. No。问完这五个问题后他会自动创建一个 pod 组件工程，并且自动执行 pod install 命令生成依赖。$ tree FlyHUD -L 2FlyHUD├── Example│   ├── FlyHUD│   ├── FlyHUD.xcodeproj│   ├── FlyHUD.xcworkspace│   ├── Podfile│   ├── Podfile.lock│   ├── Pods│   └── Tests├── LICENSE├── FlyHUD│   ├── Assets│   └── Classes├── FlyHUD.podspec├── README.md└── _Pods.xcodeproj -&gt; Example/Pods/Pods.xcodeproj10 directories, 5 files以上是生成的项目的目录结构。如果你不想使用这个目录结构则可以试试我这个工具 pod-project-template接下来就是分别向 FlyHUD/Classes 和 FlyHUD/Assets 文件夹中添加代码文件和资源，并配置 FlyHUD.podspec 文件，然后进入 Example 文件夹执行 pod install 命令，再打开项目工程可以看到，刚刚添加的组件已经在 Pods 子工程下 Development Pods/FlyHUD 中了，然后编辑 demo 工程和测试案例。 每当你向 Pod 中添加了新的文件或者更新了 podspec 都需要重新执行 pod install 命令。编辑 podspec 文件上面有提到，如果你不是用 pod lib create 创建的工程，那么就需要创建一个 podspec 文件。打开终端 cd 到 FlyHUD 项目根目录，并输入一下命令：pod spec create FlyHUD执行完之后，就创建了一个 podspec 文件，它包含很多配置项，具体怎么编辑请继续往下阅读。 将 FlyHUD 替换成你自己的组件名，此命令详细介绍可查看官方文档下面是我的一个 podspec 文件，每个字段都注释说明了它的含义。详细信息请查看官方文档Pod::Spec.new do |s|# 你的组件名称s.name = \"FlyHUD\"# 组件版本号s.version = \"1.0.0\"# 组件的简短介绍s.summary = \"The Swift version of FlyHUD.\"# 组件的详细介绍s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC# 组件的主页，一般为 Github 地址就行（如果地址无法访问，则 podspec 文件将验证不通过）s.homepage = \"https://github.com/liam-i/FlyHUD\"# 开源协议s.license = \"MIT\"# 组件的作者信息：{ \"作者名\" =&gt; \"邮箱\" }s.author = { \"liam-i\" =&gt; \"liam_i@163.com\" }# 组件最低支持的 iOS 系统版本号s.ios.deployment_target = '10.0'# 组件地址，只支持 HTTP 和 HTTPS，最好使用HTTPSs.source = { :git =&gt; \"https://github.com/liam-i/FlyHUD.git\", :tag =&gt; \"#{s.version}\" }# 组件的源代码的路径s.source_files = \"FlyHUD/Classes/*.swift\"# 资源文件地址s.resource_bundles = { 'FlyHUD' =&gt; ['FlyHUD/Assets/*.png']}# 公开头文件地址s.public_header_files = 'FlyHUD/Classes/**/*.h'# 所需的framework，多个用逗号隔开s.frameworks = 'UIKit', 'MapKit'# 组件所依赖的其他库，如果有多个需要填写多个 s.dependencys.dependency 'AFNetworking', '~&gt; 2.3'end推送到远端仓库podspec 文件编辑完成之后，需要将该项目添加并推送到远端仓库。在文章第二部分，我们已经在 GitHub 上创建了一个 FlyHUD 代码仓库，我们就推送到这里。打开终端 cd 到本地 FlyHUD 根目录，执行以下命令：git add .git commit -m \"Initial Commit\"git remote add origin git@github.com:liam-i/FlyHUD.git # 添加远端仓库git push origin main # 提交到远端仓库git tag -m \"release v0.1.0\" 0.1.0 # podspec 文件中获取 Git 版本控制的项目需要 tag 号git push --tags # 推送 tag 到远端仓库 详细的 Git 使用教程可查看【Git一个先进的分布式版本控制系统】验证 podspec 文件把项目推送到远端代码仓库之后，我们就可以验证 podspec 文件是否可用，打开终端 cd 到 podspec 文件所在目录，并执行一下命令：pod spec lint FlyHUD.podspec当你看到一下结果，说明验证通过了。 -&gt; FlyHUD (0.1.0)FlyHUD passed validation. 如果验证有任何 warning 或 error 都是不可以的，它就不能被添加到 Specs Repo 中，不过 xcode 的 warning 是可以存在的。测试 podspec 文件当 podspec 文件验证通过后，我们还需要验证 Pod 组件是可以用的，接下来我们在本地做个验证。如果你是用 pod spec create 创建的工程，则直接 cd 到 Podfile 文件目录下执行 pod install 即可。如果你不是用 pod spec create 创建的工程，则需要创建一个新的项目，在新项目的 Podfile 文件中直接指定刚才编辑好的 podspec 文件，在 Podfile 中我们可以这样编辑：use_frameworks!platform :ios, '10.0'target 'FlyHUD_Example' do pod 'FlyHUD', :path =&gt; '../' # 指定 podspec 文件所在路径end编辑好 Podfile 文件后，cd 到 Podfile 文件目录下执行 pod install 即可。当 pod install 执行完毕，且没报错。打开项目工程，可以看到文件都被加载到 Pods 子项目的 Development Pods/FlyHUD 中了，这时你编译一下工程，不报错即可。向 Public Spec Repo 提交 podspec注册作者信息第一次提交时，需要先注册你的信息：pod trunk register liam_i@163.com 'Liam' --description='FlyHUD de description.' 注意替换你的邮箱、用户名 和 组件描述。 pod trunk register 你的邮箱 ‘你的用户名’ –description=’你的描述’ 注册成功的话就会收到一份邮件，点击邮件中的链接后验证一下。我们也可以直接使用以下命令查看个人信息是否注册成功：pod trunk me注册成功的话会返回以下结果：$ pod trunk me - Name: Liam - Email: liam_i@163.com - Since: December 5th, 08:24 - Pods: - FlyHUD - Sessions: - December 5th, 08:24 - April 12th, 2022 12:34. IP: 103.206.191.69如果你的 pod 组件是由多人维护的，你也可以添加其他维护者:pod trunk add-owner POD OWNER-EMAIL例如，我们需要添加一个维护者 liam_i_other@163.com则可以这样输入：pod trunk add-owner FlyHUD liam_i_other@163.com提交 podspec注册完维护者信息之后，cd 到 podspec 文件所在目录： pod trunk push FlyHUD.podspec push 指令会先验证 podspec 文件是否有合法，验证通过后再提交到 Repo，最后会将上传的 podspec 转换为 json 文件。如果提交成功，会输出以下结果。Updating spec repo `trunk`Validating podspec -&gt; FlyHUD (0.1.0)Updating spec repo `trunk`-------------------------------------------------------------------- 🎉 Congrats 🚀 FlyHUD (0.1.0) successfully published 📅 December 5th, 08:24 🌎 https://cocoapods.org/pods/FlyHUD 👍 Tell your friends!-------------------------------------------------------------------- 详细的教程：Getting setup with Trunk向 Private Spec Repo 提交 podspec添加 Private Spec Repopod repo add REPO_NAME SOURCE_URL # E.g.: pod repo add liam-components 'git@github.com:liam-i/liam-components.git'检查添加的 Private Spec Repo 是否有效：cd ~/.cocoapods/repos/REPO_NAME # E.g.: cd ~/.cocoapods/repos/liam-componentspod repo lint .提交 podspecpod repo push REPO_NAME SPEC_NAME.podspec # E.g.: pod repo push liam-components FlyHUD.podspec 详细的教程：Private Pods从 Specs Repo 搜索组件将 podspec 提交到 Specs Repo 后，我们需要搜索一下来验证制作好的 pod 组件可以被正常使用。打开终端，输入一下命令：pod search FlyHUD搜索成功-&gt; FlyHUD (0.1.0) A short description of FlyHUD. pod 'FlyHUD', '~&gt; 0.1.0' - Homepage: https://github.com/liam-i/FlyHUD - Source: https://github.com/liam-i/FlyHUD.git - Versions: 0.1.0 [trunk repo]如果搜索不到，可执行以下命令：pod setup # 更新pod库如果 pod setup 成功后还是无法 pod search 可执行以下命令：cd ~/Library/Caches/CocoaPods # 进入 CocoaPods 的缓存文件夹rm search_index.json # 删除 search_index.json 文件pod search FlyHUD # 执行搜索命令，并重新生成 search_index.json 文件维护 podspec当一个 pod 组件库制作好了，以后肯定需要更新维护的。比如如何升级 pod 版本，如何删除 pod 组件库。升级 pod 组件版本，步骤还是和上面介绍的一样。 分别在 FlyHUD/Classes 和 FlyHUD/Assets 文件夹中添加、修改代码文件和资源 配置 FlyHUD.podspec 文件，比如 Classes、Assets、frameworks、ependency 和 version 等等 进入 Example 文件夹执行 pod install 验证 pod 组件是否可用 用 pod lib lint 验证 podspec 是否合法 推送到远端代码仓库，并打 tag 提交 podspec 到共有 Specs Repo删除已发布的 pod 组件库，可用使用以下命令：pod trunk delete NAME VERSION以上命令需要指定组件名，和组件版本号。例如：pod trunk delete FlyHUD 0.1.0 删除 pod 组件通常被认为是不好的行为，如果别人正在使用你的 pod 组件，使用 delete 会给别人带来一定的麻烦，所以请慎重考虑是否可用使用 deprecate 命令。 当你的 pod 组件版本被删除之后，此版本将永远无法再次提交到 Specs Repo " }, { "title": "CocoaPods - 安装与使用", "url": "/posts/pod-use/", "categories": "工具, CocoaPods", "tags": "CocoaPods", "date": "2021-12-04 19:55:00 +0800", "snippet": "CocoaPods 是 Swift 和 Objective-C Cocoa 项目的依赖管理器。CocoaPods 使用 Ruby 构建，可以使用 macOS 上可用的默认 Ruby 进行安装。也可以使用 rvm 和 rbenv 工具安装。安装 CocoaPods用 rvm 升级 ruby 安装 rvm：curl -L get.rvm.io | bash -s stable 让配置...", "content": "CocoaPods 是 Swift 和 Objective-C Cocoa 项目的依赖管理器。CocoaPods 使用 Ruby 构建，可以使用 macOS 上可用的默认 Ruby 进行安装。也可以使用 rvm 和 rbenv 工具安装。安装 CocoaPods用 rvm 升级 ruby 安装 rvm：curl -L get.rvm.io | bash -s stable 让配置文件生效： source ~/.bashrcsource ~/.bash_profile 查看 rvm 当前版本：rvm -v 查看已知 ruby 版本列表：rvm list known 安装最新 ruby 版本：rvm install 2.4 #注意2.4是我安装时的最新版本，以实际查看的最新版本为准 查看当前 ruby 版本：ruby -v更换 RubyGems 镜像gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/gem sources -l #查看当前数据源 注意：确保只有 gems.ruby-china.org 如果要升级 RubyGems 版本，可执行：[sudo] gem update --system # 或许需要 sudo 权限 安装/升级 CocoaPodsgem install cocoapods # 升级 CocoaPods，只需要重新 install 即可 使用默认的 Ruby 安装可能需要使用 sudo 权限。E.g.: gem install cocoapods 如果还是失败可以尝试指定安装位置。E.g.: sudo gem install -n /usr/local/bin cocoapods 如果想安装预发布版本可以使用 --pre 参数：E.g.: [sudo] gem install cocoapods --pre 详细的安装和升级教程可查看：Getting Started 设置 pod 仓库[sudo] pod setup 注意：如果 install 时有使用 sudo，这里也需要加上 sudo这一步时间比较长，耐心等待。如果想查看执行进度，请再打开一个终端，输入命令：cd ~/.cocoapodsdu -sh *查看当前 CocoaPods 版本pod --version使用 CocoaPods创建 Podfiletouch Podfile &amp;&amp; open Podfile # 创建并打开 Podfile 文件编辑 Podfile# source 'https://github.com/CocoaPods/Specs.git'source 'https://cdn.cocoapods.org/' # 推荐使用 CDN 源站platform :ios, '12.0'use_frameworks!target '&lt;Your Target Name&gt;' do pod 'FlyHUD', '~&gt; 1.0.1'end 详细的使用说明：The Podfile 详细的语法参考：Podfile Syntax Reference 安装/更新 Pods 库pod install # 安装 Pods 库，会更新 CocoaPods的spec 仓库pod update # 更新 Pods 库，会更新 CocoaPods的spec 仓库pod install --verbose --no-repo-update # 安装 Pods 库，不更新本地仓储，直接更新源pod update --verbose --no-repo-update # 更新 Pods 库，不更新本地仓储，直接更新源 解释 install 和 update 之间的区别，以及何时使用的文档：pod install vs. pod update" }, { "title": "iPhone 连接 Mac USB 反复断开重连", "url": "/posts/mac-iphone-usb/", "categories": "iOS", "tags": "iOS", "date": "2020-12-05 23:55:00 +0800", "snippet": "开发时需要在 iPhone 上调试代码，但将手机插在 Mac 的 USB 端口上总是反复的断开连接然后重新连接，导致 Xcode 不能正常的连接手机。更换 USB 端口和 Lightning 线都不能解决问题。解决方案打开终端输入一下命令：sudo killall -STOP -c usbd即强制退出 USB 进程，至此重新插上 iPhone 就正常了。", "content": "开发时需要在 iPhone 上调试代码，但将手机插在 Mac 的 USB 端口上总是反复的断开连接然后重新连接，导致 Xcode 不能正常的连接手机。更换 USB 端口和 Lightning 线都不能解决问题。解决方案打开终端输入一下命令：sudo killall -STOP -c usbd即强制退出 USB 进程，至此重新插上 iPhone 就正常了。" }, { "title": "设置本地 IPv6 Wi-Fi 网络", "url": "/posts/setup-ipv6/", "categories": "iOS", "tags": "iOS", "date": "2020-10-03 20:55:00 +0800", "snippet": "随着 IPv4 地址池的耗尽迫在眉睫，企业和蜂窝网络提供商越来越多地部署 IPv6 DNS64/NAT64 网络。DNS64/NAT64 是一个仅限 IPv6 的网络，与 IPv6 DNS64/NAT64 网络的兼容性将是 App Store 提交要求，因此 App 确保兼容性至关重要。好消息是，大多数 App 已经支持 IPv6。对于这些 App，定期测试以观察回归仍然很重要。不兼容 IP...", "content": "随着 IPv4 地址池的耗尽迫在眉睫，企业和蜂窝网络提供商越来越多地部署 IPv6 DNS64/NAT64 网络。DNS64/NAT64 是一个仅限 IPv6 的网络，与 IPv6 DNS64/NAT64 网络的兼容性将是 App Store 提交要求，因此 App 确保兼容性至关重要。好消息是，大多数 App 已经支持 IPv6。对于这些 App，定期测试以观察回归仍然很重要。不兼容 IPv6 的 App 在 DNS64/NAT64 网络上运行时可能会遇到问题。测试 App 与 IPv6 DNS64/NAT64 兼容性的最简单方法是使用 Mac 设置本地 IPv6 DNS64/NAT64 网络，这是大多数蜂窝运营商正在部署的网络类型。然后，你可以从其他设备连接到此网络进行测试。 重要信息：IPv6 DNS64/NAT64 网络设置选项在 OS X 10.11 及更高版本中可用。使用 Mac 设置本地 IPv6 Wi-Fi 网络详细步骤请查看 Apple 开发者网站：To set up a local IPv6 Wi-Fi network using your Mac使用 iPhone 设置本地 IPv6 Wi-Fi 网络使用 Mac 设置本地 IPv6 Wi-Fi 网络要求 Mac 必须带有 RJ45端口，但 Apple 新款 MacBook 都已取消了 RJ45 端口，所以我们需要使用 iPhone 设置本地 IPv6 Wi-Fi 网络。所需设备 iPhone 一台（蜂窝网络可用），用于提供 IPv4 网络。 MacBook 一台，用于模拟 IPv6 DNS64/NAT64 网络。 Lightning 线一根，用于通过 USB 链接 iPhone 和 MacBook。 其他设备一台（iPhone、Android、Mac、Windows 等），用于测试 IPv6 网络。操作步骤 用 Lightning 线将 iPhone 与 Mac 相连。如果有弹窗提示“需要信任此电脑吗？”，请点击“信任”按钮。 打开 Mac 的网络偏好设置，确保 Wi-Fi 是打开的，并且没有连接到任何网络。 关闭 iPhone 的 Wi-Fi，打开“蜂窝网络”和“个人热点”。如果在打开“个人热点”后，弹出以下弹窗，请选择“仅 USB”。 成功打开 iPhone 的“个人热点”之后，查看 Mac 的系统设置 -&gt; 网络，确保 Mac 的网络已连接到“iPhone USB”。 进入 Mac 的系统设置 -&gt; 网络 -&gt; 共享页面，找到“互联网共享”项，先按住 option 键（别松开），再点击最右侧的 “ℹ” 按钮。 先在“共享以下来源的连接”中选择“iPhone USB”，再勾选“创建NAT64网络”，最后到“使用以下端口共享给设备”中勾选“Wi-Fi”。 紧接着会进入这个“配置共享互联网的网络”页面，我们只需要输入个 Wi-Fi 密码，配置完成点击“好”按钮，如果这是弹窗提示“你确定要启动互联网共享吗？”，点击“打开”按钮。 当完成配置之后，确保“共享互联网”这个开关成功打开，这时我们的网络已共享完成。 共享完成后，在 Wi-Fi 菜单中，你应该会看到一个指向上方的微弱小箭头，表示互联网共享已启用。你现在有一个 IPv6 NAT64 网络，可以从其他设备连接到它。 IPv6 Wi-Fi 测试测试设备可以是 iPhone、iPad、Android、Mac 和 Windows 等等，这里我使用一台 iPhone X 连接刚才共享的 IPv6 NAT64 网络，链接成功后如下图所示。经过测试，我们设置的这个 IPv6 NAT64 网络可以正常使用，你可以用它来测试你的 App 了。✌🏻✌🏻✌🏻 注意： 链接上 IPv6 NAT64 网络之后的区别： 多了一个 IPv6 地址栏 DNS 也变成了 IPv6 地址 为了确保测试严格在本地 IPv6 网络上进行，请确保你的测试设备没有其他活动网络接口。例如，如果你正在使用 iOS 设备进行测试，请确保蜂窝网络服务已禁用，以便你仅通过 Wi-Fi 进行测试。 参考链接 Supporting IPv6 DNS64/NAT64 Networks" }, { "title": "iTerm2 常用快捷键", "url": "/posts/iterm2-key/", "categories": "工具, 终端", "tags": "终端", "date": "2019-02-23 21:58:58 +0800", "snippet": "iTerm2 作为 macOS 上的一款功能强大的终端模拟器，为开发者提供了众多便捷的操作方式，其中快捷键的使用可以大大提升我们的工作效率。这里，总结一下 iTerm2 的常用快捷键，帮助我们更高效地使用这款终端工具。窗口 快捷键 作用 描述 command + N 新建窗口 一个窗口 Windo...", "content": "iTerm2 作为 macOS 上的一款功能强大的终端模拟器，为开发者提供了众多便捷的操作方式，其中快捷键的使用可以大大提升我们的工作效率。这里，总结一下 iTerm2 的常用快捷键，帮助我们更高效地使用这款终端工具。窗口 快捷键 作用 描述 command + N 新建窗口 一个窗口 Window 中可以创建多个标签 Tab command + shift + W 关闭窗口   command + 回车键 或 fn + F 切换全屏   标签 快捷键 作用 描述 command + T 新建标签页 最常用的快捷键之一，可以迅速打开一个新的工作环境 command + W 关闭当前标签页 当完成一个任务，或者需要清理工作环境时，这个快捷键会非常方便 command + 数字 切换标签页   command + 方向键 按方向切换标签页   command + shift + 左右方向键 移动当前标签页的位置   分屏 快捷键 作用 描述 command + D 垂直分屏   command + shift + D 水平分屏   command + ]/[ 切换当前 Tab 中的分屏   command + option + 方向键 切换当前 Tab 中的分屏   command + W 关闭当前分屏 如果只有一个分屏，就是关闭当前标签页 滚屏 快捷键 作用 描述 Fn + Command + 上下方向键 按上下方向滚屏 以屏幕为单位滚动 Command + 上下方向键 按上下方向滚屏 以 1 行为单位滚动 Command + shift + 上下方向键 按上下方向滚屏 以 1 行为单位滚动，且滚动时光标高亮显示 文本操作与导航 快捷键 作用 描述 ctrl + / 查看当前终端中光标的位置   ctrl + Y 粘贴之前 (ctrl +U/K/W) 删除的内容   ctrl + i 或 tab 在命令行中补齐指令   双击 选中单词   三击 选中整行   四击 智能选择   !word 重复运行最近一条以“word”开头的指令 例如 !ls, !l !$ 调用上一条指令的最后一个参数作为当前指令对象 例如，假设上一条指令为 ls abc.txt bbc.txt 那么 vi !$ 相当于 vi bbc.txt !number 调用执行指定编号的历史记录指令 例如 !2, !11 查找 快捷键 作用 描述 command + F 搜索、查找 输入搜索内容后，按下 tab 键，就会自动选中搜索关键词，并且自动的帮我们复制到了剪贴板中。如果按下 shift+tab，则自动将查找内容的左边选中并复制。按 esc 退出搜索 command + ; 查看历史命令   command + shift + H 查看剪贴板历史 会自动列出输入过的命令 ctrl + S 冻结终端操作（暂停脚本）   ctrl + Q 恢复冻结（继续执行脚本）   ctrl + R 搜索命令历史 根据用户输入查找相关历史命令（reverse-i-search） 跳转 快捷键 作用 描述 ctrl + XX 在光标当前位置和之前的光标位置之间快速跳转 这在编辑长命令时非常有用 ctrl + B/F 前进/后退 相当于左右方向键 ctrl + A 到行首   ctrl + E 到行尾   ctrl + P 上一条命令 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 ctrl + N 下一条命令 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 ctrl + T 交换光标前后 2 个字符   删除 快捷键 作用 描述 command + R 清屏 只是换到新一屏，不会像 clear 一样创建一个空屏 command + K 清屏 clear ctrl + H 删除光标之前的 1 个字符   ctrl + D 删除光标之后的 1 个字符   ctrl + W 删除光标之前的 1 个单词   ctrl + U 清除当前行 无论光标在什么位置 ctrl + K 删除光标之后的所有文本   ctrl + L 清屏   ctrl + C/J/O 取消当前行输入的命令（中断操作）重新起一行   其他 快捷键 作用 描述 command + Q 退出 iTerm2 软件 与其他很多 Mac 上的软件一样 command + shift + S 保存当前窗口快照   command + alt + B 快照回放 可以对你的操作根据时间轴进行回放。可以拖动下方的时间轴，也可以按左右方向键 command + , 打开 iTerm2 的偏好设置 方便进行个性化配置和调整 ctrl + Z 暂停当前运行的进程 这在你不确定是否需要终止进程，但又想暂时挂起它时非常有用 自定义快捷键iTerm2 还支持用户自定义快捷键，可以在 iTerm2 的偏好设置中的 “Keys” 部分进行配置。这意味着你可以将经常使用的命令或操作绑定到特定的键组合上，从而根据个人习惯进一步优化工作流程。结语掌握这些常用的 iTerm2 快捷键将极大地提升我们在 macOS 上进行终端操作的效率。当然，随着对 iTerm2 的深入使用，我们会发现更多高级功能和隐藏技巧。希望这篇博客能帮助我们更好地利用这款强大的终端模拟器，提升工作效率和体验。相关链接 iTerm2 快捷键小记 iTerm2 的使用技巧及快捷键 iterm2 快捷键大全 Mac item2 常用快捷键 Mac item2常用快捷键" }, { "title": "好看命令行：iTerm2 + Oh My Zsh + Powerlevel10k", "url": "/posts/iterm2/", "categories": "工具, 终端", "tags": "终端", "date": "2019-02-02 22:58:58 +0800", "snippet": "对于 MacOS 用户来说，系统自带的 Terminal 是我们与命令行交互的默认工具。然而，默认的 Terminal 在功能和美观上都存在一些限制。在本文中，我将介绍如何使用 iTerm2、Oh My Zsh 和 Powerlevel10k 来搭建一个功能强大且美观的终端环境，同时还会推荐一些常用的插件，以提升你的命令行体验。系统 TerminalMacOS 系统自带的 Terminal ...", "content": "对于 MacOS 用户来说，系统自带的 Terminal 是我们与命令行交互的默认工具。然而，默认的 Terminal 在功能和美观上都存在一些限制。在本文中，我将介绍如何使用 iTerm2、Oh My Zsh 和 Powerlevel10k 来搭建一个功能强大且美观的终端环境，同时还会推荐一些常用的插件，以提升你的命令行体验。系统 TerminalMacOS 系统自带的 Terminal 是基于 Bash Shell 的命令行工具，它为用户提供了与操作系统交互的接口。然而，它的界面相对单调，功能也比较基础，对于追求高效和美观的用户来说，显然是不够的。iTerm2iTerm2 是一款功能强大的终端模拟器，它提供了丰富的特性和可定制性，让用户能够根据自己的喜好来配置终端的外观和行为。安装 iTerm2从 iTerm2 官网 下载，解压，然后将解压后的 iTerm.app 拖入 应用程序 里就 OK 了。使用iTerm2 提供了许多强大的功能，如多标签页、分屏、触发器、密码管理等。你可以通过其偏好设置进行个性化配置，以满足你的需求。详细教程Oh My ZshOh My Zsh 是一个开源的、社区驱动的框架，用于管理 Zsh (Z Shell) 的配置。它提供了丰富的主题和插件，让用户能够轻松地定制自己的命令行界面和增强命令行功能。安装 Oh My Zsh可以通过命令行使用 curl 或 wget 安装 Oh My Zsh。详细教程# Install oh-my-zsh via curl$ sh -c \"$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"# Install oh-my-zsh via wget$ sh -c \"$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\"也可以使用 GitHub 之外的镜像安装。比如你所在地区屏蔽了 raw.githubusercontent.com，则可能需要使用此方式：# Install oh-my-zsh via curl$ `sh -c \"$(curl -fsSL https://install.ohmyz.sh/)\"`# Install oh-my-zsh via wget$ `sh -c \"$(wget -O- https://install.ohmyz.sh/)\"` 注意： 安装 Oh My Zsh 会将 .zshrc 文件 (如果有) 重命名为 .zshrc.pre-oh-my-zsh，并再重新生成了一个 .zshrc。 安装完成后，我们需要将 .zshrc.pre-oh-my-zsh 中需要的配置拷贝到新的 .zshrc 中。 完成以上步骤后执行 source ~/.zshrc 让配置文件生效。 安装完成后，重新启动 iTerm2 查看配置是否生效。高级安装点击此处，查看高级安装教程。例如：自定义目录安装、无人值守安装、Fork 存储库安装 和 手动 clone 安装 等。更新 Oh My Zsh自动更新默认情况下，系统会每 2 周提示你检查一次更新。我们也可以设置更新模式，点击此处查看设置详情。手动更新如果你想在任何时间点更新（例如有人刚刚发布了一个新插件而你不想等待一周？）你只需运行：omz update卸载 Oh My Zsh如果你想卸载 oh-my-zsh，只需从命令行运行 uninstall_oh_my_zsh。它将自行删除并恢复你之前的 bash 或 zsh 配置。详细教程使用通过编辑 ~/.zshrc 文件，你可以配置 Oh My Zsh 的主题、插件等。同时，Oh My Zsh 还提供了丰富的快捷键和命令别名，可以大大提高你的命令行效率。详细教程Powerlevel10kPowerlevel10k 是一个为 Zsh 设计的强大主题，它提供了丰富的提示符定制选项和多种实用信息显示，如当前工作目录、时间、系统状态等。安装 Powerlevel10k手动安装git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ~/powerlevel10kecho 'source ~/powerlevel10k/powerlevel10k.zsh-theme' &gt;&gt;~/.zshrc国内用户可以使用 gitee.com 上的官方镜像加速下载.git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ~/powerlevel10kecho 'source ~/powerlevel10k/powerlevel10k.zsh-theme' &gt;&gt;~/.zshrcOh My Zsh 安装 克隆存储库: git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 中国用户可以使用 gitee.com 上的官方镜像加速下载. git clone --depth=1 https://gitee.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k 在 ~/.zshrc 中配置 ZSH_THEME=\"powerlevel10k/powerlevel10k\"。 Homebrew 安装brew install powerlevel10kecho \"source $(brew --prefix)/share/powerlevel10k/powerlevel10k.zsh-theme\" &gt;&gt;~/.zshrc有关 Homebrew 详细使用说明，请参考：Homebrew 酿酒术：精心调配你的 macOS 软件环境 注意： 选择手动和 Homebrew 安装，在插件管理器中也可以使用。只需确保在插件管理器中禁用当前主题即可。如果有问题请参考 故障排除。 点击此处，查看详细安装教程。 更新 Powerlevel10k手动更新如果是 手动安装，则执行此命令更新：git -C ~/powerlevel10k pullOh My Zsh 更新如果是 Oh My Zsh 安装，则执行此命令更新：git -C ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k pullHomebrew 更新如果是 Homebrew 安装，则执行此命令更新：brew update &amp;&amp; brew upgrade 注意： 更新 Powerlevel10k 后，重新启动 iTerm，或者执行 exec zsh，请勿使用 source ~/.zshrc。 点击此处，查看 详细更新教程。 卸载 Powerlevel10k点击此处，查看详细卸载教程。安装字体 Nerd Fonts安装字体如果我们需要使用一些字体图标，需要安装一个强大的字体库 (Nerd Fonts)。详细教程从这里 Nerd-Fonts’s latest GitHub release 找到名为 Hack.zip 的字体包，下载下来。然后，解压缩就会获得一些 ttf 字体文件，双击安装即可。zshrc 设置字体POWERLEVEL9K_MODE=\"nerdfont-complete\"ZSH_THEME=\"powerlevel10k/powerlevel10k\" 注意：POWERLEVEL9K_MODE 需要设置在 ZSH_THEME 之前。iTerm2 设置字体操作路径：菜单栏 –&gt; Profiles –&gt; Open Profiles –&gt; Edit Profiles –&gt; 选择 Text –&gt; 编辑 Font这样，所有的图标就都可以正常显示了。配置 Powerlevel10k自动配置运行命令 p10k configure 进入自动配置的流程，然后根据提示选择你需要的选项。命令执行完后会在用户目录下生成一个 ~/.p10k.zsh 文件。并且在 ~/.zshrc 里写入：# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh自定义配置想要更高级配置，可以编辑 ~/.p10k.zsh 文件。例如： POWERLEVEL9K_LEFT_PROMPT_ELEMENTS 显示在命令行左边区域的元素 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 显示在命令行右边区域的元素 POWERLEVEL9K_VCS_GIT_GITHUB_ICON 定义 Github 目录，需要显示的图标关于 POWERLEVEL9K_LEFT_PROMPT_ELEMENTS 和 POWERLEVEL9K_RIGHT_PROMPT_ELEMENTS 里用的字段有： 字段 描述 user 用户名 dir 当前目录名 vcs 远程仓库信息 os_icon 系统图标 date 日期 host 主机名 status 上一条命令的执行状态 time 当前时间 关于 POWERLEVEL9K_VCS_GIT_GITHUB_ICON 等图标的定制。所有出现在窗口里的图标都可以自定义，可以通过 get_icon_names 命令查看目前正在使用的图标。然后，根据显示的 KEY 就可以修改图标了。 注意：有些图标需要配合 Nerd Fonts 才能正常显示。点击此处，可以找到你想要的 图标代码，这是 Nerd Fonts 能够支持的所有图标。以下是图标代码的使用示例：POWERLEVEL9K_VCS_GIT_GITHUB_ICON='\\uf113'点击此处，查看详细文档。插件推荐Oh My Zsh 自带插件Oh My Zsh 包含 300 多个插件。这里是一些 特色插件，这里是 所有插件。点击每个插件的 README 可查看详细安装和使用说明。例如：git plugin’s README。三方插件 autojump 插件会记录你所有的访问记录，不同单独配置，直接访问即可。 zsh-autosuggestions 根据输入历史提供命令建议。 zsh-syntax-highlighting 为命令行提供语法高亮功能。 zsh-completions 提供额外的命令补全功能。 colors 文件目录美化插件。 git-open 输入 git open 在浏览器中打开 repo 网站（GitHub、GitLab、Bitbucket）。结语通过本文的介绍，我们已了解如何使用 iTerm2、Oh My Zsh 和 Powerlevel10k 来搭建一个好看的终端环境。这个环境不仅可以提升我们的工作效率，还能让我们在命令行工作中保持愉悦的心情。希望这些工具能为我们的开发工作带来便利和乐趣！相关链接 这篇 iTerm2 + Oh My Zsh 教程手把手让你成为这条街最靓的仔" }, { "title": "rbenv：Ruby 多版本管理利器", "url": "/posts/rbenv/", "categories": "工具, Ruby", "tags": "Ruby", "date": "2018-08-18 23:18:18 +0800", "snippet": "在 Ruby 开发的世界中，经常需要面对不同项目使用不同 Ruby 版本的情况。这时，一个高效、灵活且易于使用的 Ruby 版本管理工具就显得尤为重要。rbenv 正是这样一个工具，它允许开发者在同一台计算机上轻松安装、切换和管理多个 Ruby 版本。本文将详细介绍 rbenv 的安装、基本使用以及一些高级特性，帮助你更好地掌握这个强大的工具。rbenv 简介rbenv 是一个轻量级的 Ru...", "content": "在 Ruby 开发的世界中，经常需要面对不同项目使用不同 Ruby 版本的情况。这时，一个高效、灵活且易于使用的 Ruby 版本管理工具就显得尤为重要。rbenv 正是这样一个工具，它允许开发者在同一台计算机上轻松安装、切换和管理多个 Ruby 版本。本文将详细介绍 rbenv 的安装、基本使用以及一些高级特性，帮助你更好地掌握这个强大的工具。rbenv 简介rbenv 是一个轻量级的 Ruby 版本管理工具，通过修改环境变量来控制当前使用的 Ruby 版本。它不会干扰系统自带的 Ruby 环境，而是为用户提供一个隔离的 Ruby 运行环境。这意味着你可以根据项目需求，轻松切换到所需的 Ruby 版本，确保项目的兼容性和运行稳定性。安装 rbenvHomebrew 安装 在 macOS (或 Linux) 系统上，建议使用 Homebrew 安装 rbenv。详细教程 brew install rbenv ruby-build Homebrew 详细教程可查看： Homebrew 酿酒术：精心调配你的 macOS 软件环境 在 shell 中加载 rbenv 运行下面命令，并按照打印的说明进行操作： rbenv init 例如，下面这个示例，我们运行 rbenv init 后，提示将 eval \"$(rbenv init - zsh)\" 添加到 ~/.zshrc 文件中，才能自动加载 rbenv。 $ rbenv init# Load rbenv automatically by appending# the following to ~/.zshrc:eval \"$(rbenv init - zsh)\" 执行 source ~/.zshrc 或者关闭终端窗口并打开一个新窗口，让我们的更改生效。 克隆 Git 仓库安装 对于更自动化的安装，可以使用 rbenv-installer。如果更喜欢手动方法安装，请按照以下步骤操作。 将 rbenv 克隆到 ~/.rbenv: git clone https://github.com/rbenv/rbenv.git ~/.rbenv 配置 shell 来加载 rbenv: 详细教程 对于 bash: 在 macOS (或 Linux) 系统上，bash 通常通过以下方式配置 ~/.bash_profile: echo 'eval \"$(~/.rbenv/bin/rbenv init - bash)\"' &gt;&gt; ~/.bash_profile 对于 Zsh: echo 'eval \"$(~/.rbenv/bin/rbenv init - zsh)\"' &gt;&gt; ~/.zshrc 如果你好奇，请查看此处以了解 init 的作用。 执行 source ~/.zshrc 或者关闭终端窗口并打开一个新窗口，让我们的更改生效。 卸载 rbenvrbenv 的简单性使得临时禁用或从系统中卸载它变得很容易。详细教程 要禁用 rbenv 管理你的 Ruby 版本，只需从 shell 启动配置中注释或删除 rbenv init 行即可。这将从 PATH 中删除 rbenv shims 目录，并且将以后的使用（例如 ruby）将执行系统版本 Ruby，完全绕过 rbenv。 禁用后，rbenv 仍可在命令行上访问，但你的 Ruby 应用程序不会受到版本切换的影响。 要完全卸载 rbenv，请执行步骤(1)，然后删除 rbenv 根目录。这将删除安装在 `rbenv root`/versions/ 下的所有 Ruby 版本： rm -rf \"$(rbenv root)\" 如果你已使用包管理器安装了 rbenv，则最后一步执行 rbenv 包删除： Homebrew：brew uninstall rbenv Debian、Ubuntu 及其衍生版本：sudo apt purge rbenv Archlinux 及其衍生版本：sudo pacman -R rbenv rbenv 基本使用安装 Ruby 版本rbenv install 命令不随 rbenv 一起提供，而是由 ruby​​-build 插件提供。在尝试安装 Ruby 之前，请检查你的构建环境是否具有必要的工具和库。然后：rbenv install -l # 列出最新的稳定版本rbenv install -L # 列出所有本地版本rbenv install 3.3.0 # 安装 Ruby 版本要对 BUILD FAILED 场景进行故障排除，请查看 ruby-build 讨论部分。 如果 rbenv install 命令找不到，你可以将 ruby-build 作为插件安装： git clone https://github.com/rbenv/ruby-build.git \"$(rbenv root)\"/plugins/ruby-build 设置 Ruby 版本安装完后，需要设置 Ruby 版本以完成安装并开始使用 Ruby，你可以使用 rbenv versions 命令查看已安装的版本列表。要切换/设置到特定版本，请运行：rbenv global 3.3.0 # 设置本机的默认 Ruby 版本，你可以替换为你已安装的版本号# 或:rbenv local 3.3.0 # 设置该目录的 Ruby 版本，你可以替换为你已安装的版本号# 或:rbenv shell 3.3.0 # shell 环境，切换到 Ruby 3.3.0 版本，你可以替换为你已安装的版本号除了 rbenv install 命令之外，你还可以手动下载并编译 Ruby 作为 ~/.rbenv/versions 的子目录。该目录中的内容也可以是安装在文件系统其他位置的 Ruby 版本的符号链接。安装 Ruby gem例如，使用 rbenv local 3.3.0 为你的项目选择 Ruby 版本。然后，像平常一样继续安装 gems：gem install bundler 你不应该使用 sudo 来安装 gem。通常，Ruby 版本将安装在你的主目录下，因此你的用户可以写入。如果你在安装 gems 时收到“你没有写入权限”错误，则很可能你的“系统” Ruby 版本仍然是全局默认版本。使用 rbenv global &lt;version&gt; 更改它，然后重试。使用 gem env 检查 gem 的安装位置：gem env home# =&gt; ~/.rbenv/versions/&lt;version&gt;/lib/ruby/gems/...卸载 Ruby 版本随着时间的推移，你安装的 Ruby 版本将累积在 ~/.rbenv/versions 目录中。要删除旧的 Ruby 版本，只需 rm -rf 你要删除的版本的目录即可。你可以使用 rbenv prefix 命令查找特定 Ruby 版本的目录，例如 rbenv prefix 3.3.0。ruby-build 插件提供了 rbenv uninstall 命令来自动执行删除过程。rbenv uninstall 3.3.0 # 自动执行删除 Ruby 版本常用命令你需要了解的主要 rbenv 命令是。详细教程rbenv versions列出 rbenv 已知的所有 Ruby 版本，并在当前活动版本旁边显示一个星号。$ rbenv versions system 2.7.4* 3.3.0 (set by /Users/liam/.rbenv/version) jruby-9.4.6.0 mruby-3.3.0 truffleruby-24.0.1rbenv version显示当前活动的 Ruby 版本，以及有关其设置方式的信息。$ rbenv version3.3.0 (set by /Users/liam/.rbenv/version)rbenv local通过将版本名称写入当前目录中的 .ruby-version 文件来设置本地应用程序特定的 Ruby 版本。此版本覆盖全局版本，并且可以通过设置 RBENV_VERSION 环境变量或使用 rbenv shell 命令来覆盖自身。rbenv local 3.1.2当不带版本号运行时，rbenv local 会报告当前配置的本地版本。你还可以取消设置本地版本：rbenv local --unsetrbenv global通过将版本名称写入 ~/.rbenv/version 文件来设置要在所有 shell 中使用的 Ruby 全局版本。此版本可以通过特定于应用程序的 .ruby-version 文件或通过设置 RBENV_VERSION 环境变量来覆盖。rbenv global 3.1.2特殊版本名称 system 告诉 rbenv 使用系统 Ruby（通过搜索 $PATH 来检测）。当没有版本号运行时，rbenv global 报告当前配置的全局版本。rbenv shell通过在 shell 中设置 RBENV_VERSION 环境变量来设置特定于 shell 的 Ruby 版本。此版本覆盖特定于应用程序的版本和全局版本。rbenv shell jruby-9.4.6.0当没有版本号运行时，rbenv shell 会报告 RBENV_VERSION 的当前值。你还可以取消设置 shell 版本：rbenv shell --unset 请注意，你需要启用 rbenv 的 shell 集成（安装说明的步骤 3）才能使用此命令。如果你不想使用 shell 集成，你可以简单地自己设置 RBENV_VERSION 变量： export RBENV_VERSION=jruby-9.4.6.0 rbenv rehash为 rbenv 已知的所有 Ruby 可执行文件安装 shims (~/.rbenv/versions/*/bin/*)。通常你不需要运行此命令，因为它会在安装 gems 后自动运行。rbenv rehashrbenv which显示给定可执行文件的，的完整路径。$ rbenv which irb/Users/liam/.rbenv/versions/3.3.0/bin/irbrbenv whence列出包含指定可执行文件名称的所有 Ruby 版本。$ rbenv whence rackup3.3.0jruby-9.4.6.0truffleruby-24.0.1环境变量 名称 默认 描述 RBENV_VERSION   指定要使用的 Ruby 版本。另请参阅 rbenv shell RBENV_ROOT ~/.rbenv 定义 Ruby 版本和 shims 所在的目录。另请参阅 rbenv root RBENV_DEBUG   输出调试信息。例如：rbenv --debug &lt;subcommand&gt; RBENV_HOOK_PATH 查看 wiki 搜索 rbenv hooks 查看路径列表 RBENV_DIR $PWD 开始搜索 .ruby-version 文件的目录 插件支持rbenv 还支持通过插件来扩展功能。例如，ruby-build 和 rbenv-vars 插件可以让你更方便地安装和管理 Ruby 版本。你可以通过 Homebrew 或直接从 Git 仓库安装这些插件，并使用它们来简化 Ruby 版本的安装和管理过程。ruby-build安装 ruby-build 插件的命令如下。详细教程# 通过 Homebrew 安装brew install ruby-build# 或者通过 Git 安装git clone https://github.com/rbenv/ruby-build.git \"$(rbenv root)\"/plugins/ruby-build安装完成后，你可以使用 ruby-build 命令来安装和管理 Ruby 版本，而无需手动下载和编译 Ruby 源代码。ruby-vars安装 rbenv-vars 插件的命令如下。详细教程# 通过 Homebrew 安装brew install rbenv-vars# 或者通过 Git 安装git clone https://github.com/rbenv/rbenv-vars.git \"$(rbenv root)\"/plugins/rbenv-vars安装完成后，你可以使用 ruby-vars 命令让你在生成 Ruby 进程之前设置全局和特定于项目的环境变量。结语rbenv 是一个功能强大的 Ruby 版本管理工具，它允许开发者在同一台计算机上轻松安装、切换和管理多个 Ruby 版本。通过使用 rbenv，你可以确保你的项目在正确的 Ruby 环境中运行，从而提高开发效率和代码质量。随着 Ruby 生态系统的不断发展，rbenv 将继续成为开发者不可或缺的工具之一。希望本文能帮助你更好地理解和使用 rbenv，为你的 Ruby 开发之旅提供便利！相关链接 Homebrew 酿酒术：精心调配你的 macOS 软件环境 https://brew.sh/ https://github.com/rbenv/rbenv https://github.com/rbenv/ruby-build https://github.com/rbenv/rbenv-vars" }, { "title": "“Authenticating with the iTunes store” 或 “正在通过 iTunes Store 进行鉴定” 的完美解决办法", "url": "/posts/app-upload/", "categories": "iOS", "tags": "iOS, ipa", "date": "2017-06-18 21:55:04 +0800", "snippet": "用 Xcode 提交 app 到 iTunes store 时总是卡死在 “Authenticating with the iTunes store”。改 DNS、用 VPN 都不行，全局、自动代理模式全都试过了。网上找解决办法，有很多人推荐使用 “Application Loader” 上传，但是使用 Application Loader 提交时又卡死在 “正在通过 iTunes Stor...", "content": "用 Xcode 提交 app 到 iTunes store 时总是卡死在 “Authenticating with the iTunes store”。改 DNS、用 VPN 都不行，全局、自动代理模式全都试过了。网上找解决办法，有很多人推荐使用 “Application Loader” 上传，但是使用 Application Loader 提交时又卡死在 “正在通过 iTunes Store进行鉴定” 。好吧，彻底无语！！！解决办法不管怎么样 app 总得上传吧！继续上网寻求办法，终于皇天不负苦心人，在 苹果开发者论坛 里让我给淘着了。这是一个叫 Kumobiuslvan 的大神提供的方法，这个办法非常 perfect…😊😊😊好了简单介绍下这个方法。打开终端并运行以下命令：$ cd ~ # 进入用户根目录$ mv .itmstransporter/ .old_itmstransporter/ # 将名为 itmstransporter 的隐藏文件重命名为 old_itmstransporter$ /Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/itms/bin/iTMSTransporter # 运行 Application Loader.app 包里的 iTMSTransporter 程序当3条命令都执行完成后再用，Xcode 或 Application Loader 上传。补充注意当第三条命令里的所有请求都返回 ... updated bundle successfully retrieved. 才算成功，效果如下：$ cd ~$ mv .itmstransporter/ .old_itmstransporter/$ /Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/itms/bin/iTMSTransporter [2017-06-20 00:37:16 CST] &lt;main&gt; INFO: Transporter is searching for updated software components.[2017-06-20 00:38:03 CST] &lt;main&gt; DEBUG: Analyzing remote bundle resource com.apple.transporter.asperasupport...[2017-06-20 00:38:23 CST] &lt;main&gt; DEBUG: ... updated bundle successfully retrieved...................[2017-06-20 00:40:25 CST] &lt;main&gt; DEBUG: Analyzing remote bundle resource slf4j.log4j12...[2017-06-20 00:40:25 CST] &lt;main&gt; DEBUG: ... updated bundle successfully retrieved.[2017-06-20 00:40:25 CST] &lt;main&gt; INFO: Transporter has been successfully updated. The updated components will be available the next time Transporter runs...................如果有些请求返回 Unable to download a software component 或 ... update attempt failed, aborting. 这种错误。你可以检查下是否有开启 VPN，如果有开启先关闭 VPN 再试下。$ cd ~$ mv .itmstransporter/ .old_itmstransporter/$ /Applications/Xcode.app/Contents/Applications/Application\\ Loader.app/Contents/itms/bin/iTMSTransporter [2017-06-20 00:27:02 CST] &lt;main&gt; INFO: Transporter is searching for updated software components.[2017-06-20 00:27:13 CST] &lt;main&gt; DEBUG: ... updated bundle successfully retrieved.[2017-06-20 00:28:16 CST] &lt;main&gt; DEBUG: Analyzing remote bundle resource com.apple.its.epubcheck-runner...[2017-06-20 00:30:05 CST] &lt;main&gt; INFO: Unable to download a software component..................[2017-06-20 00:30:05 CST] &lt;main&gt; DEBUG: ... update attempt failed, attempting retry.[2017-06-20 00:30:05 CST] &lt;main&gt; INFO: Unable to download a software component..................[2017-06-20 00:30:05 CST] &lt;main&gt; DEBUG: ... update attempt failed, aborting.[2017-06-20 00:30:05 CST] &lt;main&gt; INFO: One or more software components could not be updated. This may cause reduced functionality. Please download and use the latest Transporter installer from iTunes Connect..................." }, { "title": "Carthage - 发布 Framework", "url": "/posts/carthage-push/", "categories": "工具, Carthage", "tags": "Carthage", "date": "2017-06-10 20:45:45 +0800", "snippet": "通过 Carthage 发布 Framework 之前我们需要注意以下两点情况： 1. Carthage 只支持 Dynamic frameworks。 2. Dynamic frameworks 在 OSX 上支持任何版本，iOS 上只支持 iOS8 及以上版本。然后，我们可以通过 3 步来制作、发布以及使用 framework。1. 分享你的 Xcode schemesCar...", "content": "通过 Carthage 发布 Framework 之前我们需要注意以下两点情况： 1. Carthage 只支持 Dynamic frameworks。 2. Dynamic frameworks 在 OSX 上支持任何版本，iOS 上只支持 iOS8 及以上版本。然后，我们可以通过 3 步来制作、发布以及使用 framework。1. 分享你的 Xcode schemesCarthage 只构建从 .xcodeproj 分享出来的 Xcode schemes。 选择 Manager Schemes… 勾上shared (这样Carthage就可以编译你的工程)2. 检测 intended schemes 是否能构建成功carthage build --no-skip-current 以上命令执行完，会在项目里生成一个 Carthage 文件夹。 Carthage 存放编译后的 Framework 文件 (不需要提交到 Git)。我们可以在 .gitignore 里添加一行 Carthage/Build 将他过滤掉。3. 发布 Framework将该类库 push 到 Github，并打一个 tag。到此我们就可以在其他项目中使用此类库了。 提示： 如何将项目提交到 GitHub 查看：Git 一个先进的分布式版本控制系统 Carthage 的使用查看：Carthage 安装与使用 " }, { "title": "Carthage - 安装与使用", "url": "/posts/carthage-use/", "categories": "工具, Carthage", "tags": "Carthage", "date": "2017-06-04 20:05:50 +0800", "snippet": "Carthage 一个低耦合，更灵活的管理器；使用 xcodebuild 来编译依赖项目成 Framework。Carthage 是由 Swift 语言写的，只支持动态框架，只支持 iOS 8+。安装 Carthage 用 Homebrew 安装（推荐）： brew update # 更新 Homebrewbrew install carthage #...", "content": "Carthage 一个低耦合，更灵活的管理器；使用 xcodebuild 来编译依赖项目成 Framework。Carthage 是由 Swift 语言写的，只支持动态框架，只支持 iOS 8+。安装 Carthage 用 Homebrew 安装（推荐）： brew update # 更新 Homebrewbrew install carthage # 安装 carthagebrew upgrade carthage # 升级 carthage 如果你的 Mac 未安装 Homebrew 可以使用以下命令安装： /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 从 Github 下载 .pkg 安装包： 下载地址：Carthage 查看 Carthage 版本carthage version在项目中使用 Carthage以 FlyHUD 为例。 在项目根目录下创建 Cartfile 文件，输入 github \"liam-i/FlyHUD\" 注：版本的含义如下： ~&gt; 4.4 表示使用版本4.4以上但是低于5.0的最新版本，如4.5, 4.9 == 4.4 表示使用4.4版本 &gt;= 4.4 表示使用4.4或更高的版本 如果你没有指明版本号，则会自动使用最新的版本 保存，并在终端执行以下命令： carthage update #拉取源代码并自动编译全平台的Frameworkcarthage update --platform iOS #拉取源代码并自动编译iOS平台Framework 当命令执行完毕后，会在你的项目根目录下生成一个 Cartfile.resolved 文件和一个 Carthage 文件夹。 Cartfile.resolved 用来跟踪项目当前所用的依赖版本号，为了保持多端开发一致 (需要提交到 Git) Carthage 存放依赖库的源文件和编译后的文件 (不需要提交到 Git) 打开 project 文件，找到 target-&gt;General，将 Carthage/Build 中的 .framework 拖入 Embedded Binaries 即可。 因为 Carthage 目前只支持 dynamic framework 所以一定要拖入 Embedded Binaries 里。 更改 Xcode 版本如果你的电脑装了多个 Xcode，你可以使用以下2种方式，指定用哪个版本的 Xcode 编译 Framework 命令行方式： sudo xcode-select -s /Applications/Xcode-beta.app/Contents/Developer Xcode-beta.app 就是对应你的 Xcode 版本。 打开 Xcode -&gt; Preferences -&gt; Locations 中切换 Command Line Tools 版本。 " }, { "title": "Git 一个先进的分布式版本控制系统", "url": "/posts/git-basic/", "categories": "工具, git", "tags": "git", "date": "2017-05-20 23:16:14 +0800", "snippet": "分布式版本控制系统与集中式版本控制系统最大的区别就是它没有“中央服务器”；每个人的电脑上都是一个完整的版本库，同事之间只需要将自己的修改推送给对方，就可以互相看到对方的修改了。不过在实际使用 Git 的时候，其实很少在两个人之间的电脑互推。通常也有一台充当“中央服务器”的电脑，这个服务器仅仅是用来方便同步大家的修改。安装 Git因为 Xcode 自带的有 Git 所以就不在介绍了。创建版本库...", "content": "分布式版本控制系统与集中式版本控制系统最大的区别就是它没有“中央服务器”；每个人的电脑上都是一个完整的版本库，同事之间只需要将自己的修改推送给对方，就可以互相看到对方的修改了。不过在实际使用 Git 的时候，其实很少在两个人之间的电脑互推。通常也有一台充当“中央服务器”的电脑，这个服务器仅仅是用来方便同步大家的修改。安装 Git因为 Xcode 自带的有 Git 所以就不在介绍了。创建版本库（repository）git init # 创建一个空的仓库 init 后用 ls -ah 命令可以看到当前目录下多了一个 .git 隐藏目录。这个目录是 Git 用来跟踪管理版本库的，不要随意手动修改这个目录里的任何文件。把文件添加到版本库（add）git add . # 把当前目录下的所有文件添加到仓库 add 只是把文件修改添加到暂存区把文件提交到仓库（commit）git commit -m \"日志消息\" commit 是把暂存区里的修改提交到当前分支查看版本库当前的状态（status）git status查看文件修改（diff）git diff README.mdgit diff HEAD -- README.md # 查看README.md 文件在工作区和版本库里面最新版本的区别查看历史记录（log）git log # 显示从最近到最远的提交日志git log --pretty=oneline # 只显示版本号和修改内容回退版本（reset）git reset --hard HEAD^ # 回退到上一个版本当你回退到了某个版本后，又想恢复到新版本怎么办？想回到新版本必须找到新版本的版本号。我们可以用 git reflog 来查询。git reflog # 查询每次提交的 idgit reset --hard 3637964 # 3637964 是最新版本的版本号撤销暂存区的修改（reset）git reset HEAD README.md # 把暂存区的修改撤销掉，重新放回工作区撤销工作区的修改（checkout）git checkout -- README.md # 把 README.md 文件在“工作区”的修改全部撤销 -- 一定要有，没有 -- 就变成了“切换到另一个分支”的命令删除文件（rm）git rm README.md # 删除暂存区、工作区和分支上的文件git rm --cached README.md # 删除暂存区和分支上的文件；工作区里的文件保留远程仓库1 - 配置 SSH Key：以 GitHub 为例由于本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置： 第1步：创建 SSH Key。在用户主目录下 Finder前往~/.ssh，看看有没有 .ssh 目录如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到第2步。如果没有就用以下命令创建 ssh-keygen -t rsa -C \"youremail@example.com\" # 把邮件换成你自己的邮件地址，然后一路回车，无需设置密码 .ssh 里有 id_rsa 和 id_rsa.pub 两个文件，id_rsa 是私钥不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。 第2步：登陆 GitHub，打开 “Settings”，“SSH and GPG keys” 页面：然后，点 “New SSH Key”，填上任意 Title，在 Key 文本框里粘贴 id_rsa.pub 文件的内容：然后点击 “Add SSH Key”，你就应该看到已经添加的 Key。 远程仓库2 - 关联和推送：以 GitHub 为例情景：我们先有本地 Git 仓库，后有远程仓库，需要将本地和远程仓库关联。 第1步：关联远程仓库（假如你在 GitHub 上已经新建了一个仓库 LearnGit）。 git remote add origin git@github.com:liam-i/LearnGit.git 把上面的 liam-i 替换成你自己的 GitHub 账户名。 第2步：把本地库的所有内容推送到远程库。 git push -u origin main # 把当前分支 main 推送到远程 -u 不但会把本地的 main 推送到远程 main 分支，还会把本地的 main 和远程的 main 关联起来。第一次推时需要，以后再推/拉时就可以简化了。 第一次推送有可能报以下错误： LiamMacBook-Pro:LearnGit liam$ git push -u origin main To github.com:liam-i/LearnGit.git ! [rejected] main -&gt; main (fetch first) error: failed to push some refs to 'git@github.com:liam-i/LearnGit.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 造成这个错误的原因是 Git 仓库中已经有一部分代码，所以它不允许你直接把你的代码推送上去。于是我们有2个选择方式： 强推，用你本地的代码替代 Git 仓库内的内容： git push -f origin main # 注：会覆盖远程仓库里的内容 把服务器上的内容合并到本地在推送：git pull 可是这时又报错了。 LiamMacBook-Pro:LearnGit liam$ git pull fatal: refusing to merge unrelated histories 这时我们需要用以下两个命令配置 .git/config 文件： git config branch.main.remote origin # 当本地是 main 分支, 默认的 remote 就是 origin git config branch.main.merge refs/heads/main # 当本地是 main 分支使用 git pull 时，没有指定 remot 分支，那么 git 就会采用默认的 origin 来 merge 在 main 分支上所有的改变 这时我们已经可以正常的 pull 和 push 了。完整操作如下： LiamMacBook-Pro:LearnGit liam$ git config branch.main.remote origin LiamMacBook-Pro:LearnGit liam$ git config branch.main.merge refs/heads/main LiamMacBook-Pro:LearnGit liam$ git pull Already up-to-date. LiamMacBook-Pro:LearnGit liam$ git push origin main Counting objects: 26, done. Delta compression using up to 8 threads. Compressing objects: 100% (21/21), done. Writing objects: 100% (26/26), 12.68 KiB | 0 bytes/s, done. Total 26 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), done. To github.com:liam-i/LearnGit.git f01930f..0892bfe main -&gt; main 远程仓库3-克隆：以 GitHub 为例情景：我们需要从零开发，那么最好的方式是先创建远程仓库，然后克隆。 第1步：登录GitHub新建一个仓库 LearnGit。 第2步：克隆到本地： git clone git@github.com:liam-i/LearnGit.git 分支管理1 - 创建/切换分支（branch/checkout）git branch MyBranch # 创建分支 MyBranchgit checkout MyBranch # 切换到分支 MyBranchgit checkout -b MyBranch # 创建并切换到分支 MyBranch分支管理2 - 删除/查看分支（branch）git branch -d MyBranch # 删除 MyBranch 分支git branch # 查看当前分支分支管理3 - 合并分支/解决冲突（merge）git merge MyBranch # 将 MyBranch 合并到当前分支# 注：如果可能 Git 会用 Fast forward 模式，这种模式下删除分支后，会丢掉分支信息。git merge --no-ff -m \"merge with no-ff\" MyBranch # 将 MyBranch 合并到当前分支# 注：`--no-ff` 强制禁用 Fast forward 模式，Git 会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。LiamMacBook-Pro:LearnGit liam$ git checkout main # 切回 main 分支LiamMacBook-Pro:LearnGit liam$ git merge MyBranch # 将 MyBranch 合并到 mainAuto-merging README.mdCONFLICT (content): Merge conflict in README.mdAutomatic merge failed; fix conflicts and then commit the result.合并分支时 README.md 文件发生冲突，必须手动解决冲突后再 commit。用 git status 也可以查看冲突的文件：LiamMacBook-Pro:LearnGit liam$ git statusOn branch mainYou have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge)Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: README.mdno changes added to commit (use \"git add\" and/or \"git commit -a\")打开 README.md 文件查看内容：class ScanViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad()&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD print(\"main -&gt; viewDidLoad\")======= print(\"MyBranch -&gt; viewDidLoad\")&gt;&gt;&gt;&gt;&gt;&gt;&gt; MyBranch }}git 用 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，======= 和 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，我们修改如下后保存：class ScanViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() print(\"main -&gt; viewDidLoad\") }}再提交git add README.md # 添加到暂存区git commit -m \"conflict fixed\" # 提交到 main 分支分支管理4 - 查看分支的合并情况（log）git log --graph # 查看分支合并图git log --graph --pretty=oneline --abbrev-commit # 查看本次分支的合并情况LiamMacBook-Pro:LearnGit liam$ git log --graph --pretty=oneline --abbrev-commit* 6deee3e Fix conflicts|\\ | * de23acd MyBranch* | 76c6451 main|/ * 873c772 ..分支管理5 - 创建 BUG 分支（stash）情景：当你接到一个修复紧急 bug 的任务时，需要创建一个分支来工作。但是，你当前正在 MyBranch 分支上进行工作，而且工作只进行到一半还没法提交。这时，我们就需要用 stash 功能，将当前工作现场“储藏”起来，等 bug 解决了再恢复现场继续工作。git stash # 把当前工作现场“储藏”起来 stash 后，用 git status 查看工作区是干净的，因此可以创建分支来修复 bug 了。 创建 bug 分支 -&gt; 解决 bug -&gt; 解决完毕 -&gt; 合并到主分支 -&gt; 删除 bug 分支当 bug 解决完毕后需要切回到原来的 MyBranch 分支继续工作：git checkout MyBranch # 切回到 MyBranch 分支git stash list # 查看被储藏的工作区git stash apply stash@{0} # 恢复指定的工作区git stash drop stash@{0} # 删除指定的 stash 内的记录orgit stash pop stash@{0} # 恢复的同时把 stash 内的指定记录也删了分支管理6 - 推送分支（push）git remote # 查看远程仓库的信息git remote -v # 查看远程仓库的更详细信息git push origin main # 将本地 main 分支推送到远程库对应的远程分支git push origin MyBranch # 将本地 MyBranch 分支推送到远程库对应的远程分支分支管理7 - 获取分支（pull）pull 之前必须要先克隆：git clone git@github.com:liam-i/LearnGit.git此时你只能看到本地的 main 分支，如果你想看到其他分支必须创建远程 origin 的 MyBranch 到本地：git checkout -b MyBranch origin/MyBranch抓取分支git pull # 把最新的提交从 origin/dev 抓下来注：第一次抓取的时候有可能会报以下错误：remote: Counting objects: 1, done.remote: Compressing objects: 100% (1/1), done.remote: Total 1 (delta 0), reused 1 (delta 0)Unpacking objects: 100% (1/1), done.From github.com:liam-i/LearnGit fc338631..201bea8 MyBranch -&gt; origin/MyBranchThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/&lt;branch&gt;这是因为本地 MyBranch 分支与远程 origin/MyBranch 分支没有关联，根据提示设置关联：git branch --set-upstream MyBranch origin/MyBranch # 设置 MyBranch 和 origin/MyBranch 的链接标签管理1 - 创建标签（tag）git tag v1.0 # 打一个标签 v1.0git tag # 查看所有标签对历史提交的版本打一个标签git log --pretty=oneline --abbrev-commit # 找到历史提交的 commit idgit tag v1.0 6279237 # 对 commit id 为 6279237 的版本打标签git tag # 查看所有标签git tag -a v1.0 -m \"version 1.0 released\" # 创建带有说明的标签git show v1.0 # 查看标签 v1.0 的信息 -a指定标签名，-m 指定说明文字标签管理2 - 操作标签（tag）git push origin v1.0 # 将标签 v1.0 推送到远程git push origin --tags # 将全部尚未推送的标签推送到远程git tag -d v1.0 # 删除本地标签 v1.0git push origin :refs/tags/v1.0 # 删除远程标签 v1.0Git 的常用配置git config --global color.ui true # 让 Git 在适当的地方显示不同的颜色配置别名：git config --global alias.co checkout # 为 checkout 配置别名 cogit config --global alias.ci commit # 为 commit 配置别名 cigit config --global alias.br branch # 为 branch 配置别名 brgit config --global alias.st status # 为 status 配置别名 st忽略特殊文件（.gitignore）在 Git 工作区的根目录下创建一个 .gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。GitHub 也为我们准备了各种配置文件：https://github.com/github/gitignore。" }, { "title": "Swift 实现从 URLString 中截取参数", "url": "/posts/url-param/", "categories": "iOS, Swift", "tags": "Swift", "date": "2016-06-18 21:34:41 +0800", "snippet": "在 iOS 开发中我们经常需要获取 URLString 中的参数值。以下方法利用 URLComponents 实现：实现方法extension String { // 从 URLString 中截取参数 var urlParameters: [AnyHashable: Any]? { // 解析url guard let urlComp...", "content": "在 iOS 开发中我们经常需要获取 URLString 中的参数值。以下方法利用 URLComponents 实现：实现方法extension String { // 从 URLString 中截取参数 var urlParameters: [AnyHashable: Any]? { // 解析url guard let urlComponents = URLComponents(string: self), let queryItems = urlComponents.queryItems else { return nil } var parameters: [AnyHashable: Any] = [:] // 遍历queryItems获取每一项参数的键值对 queryItems.forEach { (item) in // 判断是否有相同的key if let existValue = parameters[item.name], let value = item.value { // 将相同key的值存入数组中 if var existValue = existValue as? [Any] { existValue.append(value) parameters[item.name] = existValue } else { parameters[item.name] = [existValue, value] } } else { parameters[item.name] = item.value } } // 返回解析后的参数字典 return parameters }}Demo 下载地址：LPURLParse。结语一个很简单的 Demo，就此完成。" }, { "title": "Swift 实现延迟搜索", "url": "/posts/delayed-search/", "categories": "iOS, Swift", "tags": "Swift", "date": "2016-05-03 22:14:45 +0800", "snippet": "当我们在做一个搜索功能时，为了给用户一个更好的体验需要用到延迟搜索。通常做法设定一个延迟时间 1.0秒（根据需求调整），如果输入的连续时间间隔小于 1.0秒就不执行搜索方法，直到大于 1.0秒。在 iOS 下我们可以使用 perform 方法来实现，以 Swift 为例。 创建一个延迟执行请求： /// 延迟方法 /// /// - Parameters: /// - ...", "content": "当我们在做一个搜索功能时，为了给用户一个更好的体验需要用到延迟搜索。通常做法设定一个延迟时间 1.0秒（根据需求调整），如果输入的连续时间间隔小于 1.0秒就不执行搜索方法，直到大于 1.0秒。在 iOS 下我们可以使用 perform 方法来实现，以 Swift 为例。 创建一个延迟执行请求： /// 延迟方法 /// /// - Parameters: /// - aSelector: 执行延迟搜索的方法 /// - anArgument: 搜索参数 /// - delay: 设定一个延迟时间（1.0秒） open func perform(_ aSelector: Selector, with anArgument: Any?, afterDelay delay: TimeInterval) 当输入的连续时间间隔小于设定的时间 (1.0秒)，取消历史创建的延迟请求： /// 取消先前使用 perform(_:with:afterDelay:) 实例方法注册的延迟执行请求。 /// /// - Parameter aTarget: 先前使用 perform(_:with:afterDelay:) 实例方法注册的请求的目标。 open class func cancelPreviousPerformRequests(withTarget aTarget: Any) Demo 下载地址：LPDelayedSearch。 结语一个很简单的 Demo，就此完成。" }, { "title": "Mac 下 svn 默认忽略 .a 文件的解决办法", "url": "/posts/svn-ignore.a/", "categories": "工具, svn", "tags": "svn", "date": "2015-05-30 23:21:08 +0800", "snippet": "大家在使用 svn 提交项目时经常会遇到这样的问题，文件上传再下载后发现所有的 .a 文件全部丢失。问题排查之后才知道，提交项目时 .a 文件被过滤掉了，所以才会出现丢失情况。以下是 Mac 电脑下的解决办法。解决步骤 右键 Finder 在 “前往文件夹” 里输入 ~/.subversion/config 前往。 双击打开 config，搜索 global-igno...", "content": "大家在使用 svn 提交项目时经常会遇到这样的问题，文件上传再下载后发现所有的 .a 文件全部丢失。问题排查之后才知道，提交项目时 .a 文件被过滤掉了，所以才会出现丢失情况。以下是 Mac 电脑下的解决办法。解决步骤 右键 Finder 在 “前往文件夹” 里输入 ~/.subversion/config 前往。 双击打开 config，搜索 global-ignores 你会看到下面这行代码： # global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.a * *.pyc *.pyo __pycache__ *.rej *~ #*# .#* .*.swp .DS_Store [Tt]humbs.db 将其修改为： global-ignores = *.o *.lo *.la *.al .libs *.so *.so.[0-9]* *.pyc *.pyo __pycache__ *.rej *~ #*# .#* .*.swp .DS_Store [Tt]humbs.db 注意：删除行首的 # 和中间的 *.a * 保存。重启 svn 问题即可解决。 " }, { "title": "svn 常用的几个命令", "url": "/posts/svn-basic/", "categories": "工具, svn", "tags": "svn", "date": "2015-05-23 22:31:29 +0800", "snippet": "Apache Subversion (简称 svn) 是一个功能齐全的版本控制系统，最初旨在成为更好的 CVS。此后，Subversion 已经超越了取代 CVS 的最初目标，但其基本模型、设计和界面仍然受到该目标的严重影响。即使在今天，Subversion 仍然对 CVS 用户来说仍然非常熟悉。这篇文章只简单记录几个 svn 常用的命令，如果你想了解更多请查看官方文档：Quick Star...", "content": "Apache Subversion (简称 svn) 是一个功能齐全的版本控制系统，最初旨在成为更好的 CVS。此后，Subversion 已经超越了取代 CVS 的最初目标，但其基本模型、设计和界面仍然受到该目标的严重影响。即使在今天，Subversion 仍然对 CVS 用户来说仍然非常熟悉。这篇文章只简单记录几个 svn 常用的命令，如果你想了解更多请查看官方文档：Quick Start项目上传到（import）svn import -m \"New Import\" ./MyProject/ http://svn_server/ios/trunk/MyProject # 将本地 MyProject 目录下的所有文件提交到服务器 `/trunk/MyProject` 目录检出代码（checkout）svn co http://svn_server/ios/trunk/MyProject # 检出最新版本到本地svn co -r 版本号 http://svn_server/ios/trunk/MyProject # 检出指定版本到本地往版本库中添加新的文件（add）svn add filename # 添加指定文件svn add * # 添加所有文件将改动的文件提交到服务器（commit）svn ci -m \"日志消息\" # 将该路径下所有修改的文件提交到服务器将服务器的代码更新到本地（update）svn up创建分支（copy）svn cp -m \"create branch\" http://svn_server/ios/trunk/MyProject http://svn_server/ios/branches/NewBranch # 将主干 MyProject 拷贝一份到分支 NewBranch合并主干代码到分支（merge）cd NewBranch # 切换到本地分支目录svn merge http://svn_server/ios/trunk/MyProject # 将服务器主干代码合并到本地 先将服务器上的主干代码合并到本地分支；合并好并且确保本地分支运行没问题后再讲本地分支代码提交到服务器合并分支代码到主干（merge）cd MyProject # 切换到本地主干目录svn merge http://svn_server/ios/branches/NewBranch # 将服务器分支代码合并到本地创建tags（copy）svn cp http://svn_server/ios/trunk/MyProject http://svn_server/ios/tags/tag-1.0 -m \"create tag\"删除分支或tags（delete、del、remove）svn rm -m \"rm branch\" http://svn_server/ios/branches/NewBranchsvn rm -m \"rm tag\" http://svn_server/ios/tags/tag-1.0冲突解决（resolve） svn up 时如果有冲突发送 svn 通常会有以下提示（注意：“#”后面是我添加的注释）： U Classes/Message/FriendsViewController.swift # U 该文件有修改C Classes/AppDelegate.swift # C 该文件在更新时发生冲突R Vendor/Web.bundle/index.html # R 这个文件预定要被替换U Demo.xcodeproj/project.pbxproj # U 该文件有修改--- Recording mergeinfo for merge of r709 through r730 into '.': # 记录合并信息U .Summary of conflicts: # 冲突总结：Text conflicts: 1 # 有1个文本冲突Conflict discovered in file 'Classes/AppDelegate.swift'. # 文件“Classes/AppDelegate.swift”中发现冲突。Select: (p) postpone, (df) show diff, (e) edit file, (m) merge, # 选择：（p）标记冲突，稍后解决，（df）把所有的修改列出来，（e）直接编辑冲突的文件，（m）合并（这个我目前还没用过），(mc) my side of conflict, (tc) their side of conflict, #（mc）冲突以本地为准，（tc）冲突以服务器为准 ，(s) show all options: #（s）显示其他可用的命令 遇到冲突我们需要和那个与我发生冲突的哥们商量一番，所以需要推迟处理。选择：p 终端输出如下： Summary of conflicts: # 冲突总结：Text conflicts: 1 # 总共有1个文本冲突 现在我们开始解决冲突，打开 Classes/AppDelegate.swift 文件，找到冲突。（注意：“#”后面是我添加的注释）： &lt;&lt;&lt;&lt;&lt;&lt;&lt; .working // 我当前本地的版本（我把这个“友盟统计”的注释给去掉了，因为他还有用。）// 友盟统计UMAnalyticsConfig.sharedInstance().appKey = \"------\"MobClick.start(withConfigure: UMAnalyticsConfig.sharedInstance())if let version = Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String { MobClick.setAppVersion(version)}||||||| .merge-left.r708 // 我修改之前的版本（以前这个“友盟统计”被注释掉了）// // 友盟统计// UMAnalyticsConfig.sharedInstance().appKey = \"------\"// MobClick.start(withConfigure: UMAnalyticsConfig.sharedInstance())// if let version = Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String {// MobClick.setAppVersion(version)// }======= // 另外一个哥们的修改版本（他觉得这个“友盟统计”被注释掉了就没用了，所以就给删了。简单粗暴🤣🤣🤣）&gt;&gt;&gt;&gt;&gt;&gt;&gt; .merge-right.r730 经过讨论这个“友盟统计”还是有用的，所以以我当前本地版本为准。修改如下： // 友盟统计UMAnalyticsConfig.sharedInstance().appKey = \"------\"MobClick.start(withConfigure: UMAnalyticsConfig.sharedInstance()) if let version = Bundle.main.infoDictionary?[\"CFBundleShortVersionString\"] as? String { MobClick.setAppVersion(version)} 冲突文件修改好了。在终端输入 svn st 命令查看下当前 svn 状态： LiamMacBook-Pro:Demo liam$ svn stU Classes/Message/FriendsViewController.swiftC Classes/AppDelegate.swiftR Vendor/Web.bundle/index.htmlU Demo.xcodeproj/project.pbxproj? Demo.xcodeproj/project.xcworkspace/xcshareddata/Demo.xcscmblueprint 我们发现 Classes/AppDelegate.swift 这个文件的标记还是冲突 “C” 状态。我们需要用 resolve 命令去掉这个标记。命令如下： LiamMacBook-Pro:Demo liam$ svn resolve --accept working Classes/AppDelegate.swiftResolved conflicted state of 'Classes/AppDelegate.swift' 再次查看svn状态。Classes/AppDelegate.swift 的标记已经变成“M”了。 LiamMacBook-Pro:Demo liam$ svn stM Classes/Message/FriendsViewController.swiftM Classes/AppDelegate.swiftR Vendor/Web.bundle/index.htmlM Demo.xcodeproj/project.pbxproj? Demo.xcodeproj/project.xcworkspace/xcshareddata/Demo.xcscmblueprint 到此 svn 已经恢复正常状态。我们可以进行 commit 等操作了。 加锁（lock）svn lock -m \"日志消息\" test.h # 给 test.h 文件加锁解锁（unlock）svn unlock test.h # 给 test.h 文件解锁查看日志（log）svn log test.h # 显示 test.h 文件的所有修改日志查看文件详细信息（info）svn info test.h # 查看 test.h 文件详细信息比较差异（diff）svn di test.h # 比较修改后的 test.h 文件与基础版本的差异svn di -r m:n test.h # 比较版本 m 和版本 n 的差异 注：推荐使用 xcode 会更加清晰明了SVN 帮助（help）svn helpsvn help ci # 查询 ci 命令的帮助变更 svn 地址（switch）svn switch --relocate http://old_svn_server http://new_svn_server" } ]
